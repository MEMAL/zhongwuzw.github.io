<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[UIWebView相关协议方法总结]]></title>
      <url>https://zhongwuzw.github.io/2016/10/20/UIWebView%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="UIWebView-Private-Method"><a href="#UIWebView-Private-Method" class="headerlink" title="UIWebView Private Method"></a>UIWebView Private Method</h2><hr>
<ul>
<li>UIWebView dump method:<a href="https://github.com/nst/iOS-Runtime-Headers/blob/f7f2c13158ff4ecd15b92eefb5c5d365b126db05/Frameworks/UIKit.framework/UIWebView.h" target="_blank" rel="external">UIWebView.h</a></li>
<li>设置<code>UIWebView</code>在<code>WebThread</code>线程下进行渲染，不占用主线程，代码如下：<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[_webView <span class="string">performSelector:</span><span class="meta">@selector</span>(<span class="string">_setDrawInWebThread:</span>) <span class="string">withObject:</span><span class="meta">@YES</span>];</div><div class="line">[_webView <span class="string">performSelector:</span><span class="meta">@selector</span>(<span class="string">_setDrawsCheckeredPattern:</span>) <span class="string">withObject:</span><span class="meta">@YES</span>];</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="WebResourceLoadDelegate-Protocol"><a href="#WebResourceLoadDelegate-Protocol" class="headerlink" title="WebResourceLoadDelegate Protocol"></a>WebResourceLoadDelegate Protocol</h2><hr>
<ul>
<li><p><code>- (id)webView:(WebView *)sender identifierForInitialRequest:(NSURLRequest *)request fromDataSource:(WebDataSource *)dataSource</code></p>
<p>  该方法返回一个标识符对象，网页中的每一个资源都会调用该方法。资源包括网页中嵌入的图片、脚本、<code>CSS</code>、嵌入在<code>frame</code>中的页面。</p>
</li>
</ul>
<a id="more"></a>
<h2 id="UIWebViewDelegate-Protocol"><a href="#UIWebViewDelegate-Protocol" class="headerlink" title="UIWebViewDelegate Protocol"></a>UIWebViewDelegate Protocol</h2><hr>
<ul>
<li><p><code>- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType</code></p>
<p>  webView在加载一个frame之前会回调该方法，加载frame的情形包括加载新的页面、加载<code>iframe</code>的url时。<code>navigationType</code>变量是一个枚举值，标识用户的动作，如点击、提交表单、前进、重载、重新提交表单、以及其他，其他包括重定向等。</p>
</li>
<li><p><code>- (void)webViewDidFinishLoad:(UIWebView *)webView</code></p>
<p>  注意，该方法并不是表示webView完成了网页的加载，而是表示完成了一个frame的加载，所以可能会出现加载一个网页时被调用多次的情况。 </p>
</li>
</ul>
<h2 id="WebFrameLoadDelegate-Protocol"><a href="#WebFrameLoadDelegate-Protocol" class="headerlink" title="WebFrameLoadDelegate Protocol"></a>WebFrameLoadDelegate Protocol</h2><hr>
<ul>
<li><p><code>- (void)webView:(WebView *)sender didFinishLoadForFrame:(WebFrame *)frame</code></p>
<p>  当<code>frame</code>完成时调用，既<code>frame</code>的所有资源都已经加载完成。<code>WebFrame</code>封装了一个单独的<code>frame</code>元素，而一个完整的页面则由一个<code>WebFrame</code>的层级树组成，根<code>WebFrame</code>称为<code>main frame</code>，每一个<code>WebFrame</code>都对应一个<code>WebFrameView</code>，其用来显示<code>frame</code>的内容。</p>
</li>
</ul>
<ul>
<li><p><code>- (void)webView:(WebView *)sender didReceiveTitle:(NSString *)title forFrame:(WebFrame *)frame</code></p>
<p>  当<code>frame</code>获取到<code>title</code>时调用，该方法可能会被调用多次，想要及时更新标题的话可以实现该方法。</p>
</li>
</ul>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><hr>
<ol>
<li>在请求资源数据时，由于是异步的，所以可能成功，也可能失败，因此<code>Data Sources</code>就分为<code>Provisional</code>和<code>Committed</code>。一开始，<code>data source</code>是<code>Provisional</code>的，因为还不知道页面是否会加载成功，只要有响应数据到来，<code>data source</code>就将变成<code>Committed</code>的。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用PyMySQL处理大结果集的方法]]></title>
      <url>https://zhongwuzw.github.io/2016/10/13/%E4%BD%BF%E7%94%A8PyMySQL%E5%A4%84%E7%90%86%E5%A4%A7%E7%BB%93%E6%9E%9C%E9%9B%86%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="使用PyMySQL处理大结果集的方法"><a href="#使用PyMySQL处理大结果集的方法" class="headerlink" title="使用PyMySQL处理大结果集的方法"></a>使用PyMySQL处理大结果集的方法</h2><hr>
<p>最近公司项目需要向别的数据库中获取数据并同步到自己的数据库，由于是别人的库，所以没法直接使用<code>Master-Slave</code>同步，最终选择Python脚本来获取。</p>
<p>选择了<a href="https://github.com/PyMySQL/PyMySQL" target="_blank" rel="external">PyMySQL</a>客户端库，按照其官方教程，代码比较简单，类似如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import pymysql.cursors</div><div class="line"></div><div class="line"><span class="comment"># Connect to the database</span></div><div class="line">connection = pymysql.connect(host=<span class="string">'localhost'</span>,</div><div class="line">                             user=<span class="string">'user'</span>,</div><div class="line">                             password=<span class="string">'passwd'</span>,</div><div class="line">                             db=<span class="string">'db'</span>,</div><div class="line">                             charset=<span class="string">'utf8mb4'</span>,</div><div class="line">                             cursorclass=pymysql.cursors.DictCursor)</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">with</span> connection.cursor() <span class="keyword">as</span> cursor:</div><div class="line">        <span class="comment"># Read a single record</span></div><div class="line">        sql = <span class="string">"SELECT `id`, `password` FROM `users`"</span></div><div class="line">        cursor.execute(sql)</div><div class="line">        <span class="built_in">result</span> = cursor.fetchall()</div><div class="line">        print(<span class="built_in">result</span>)</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    connection.<span class="built_in">close</span>()</div></pre></td></tr></table></figure>
<p><code>PyMySQL</code>在获取数据时提供了<code>fetchone()</code>和<code>fetchall()</code>函数来获取结果集，后来调试的时候，发现，不管是哪种方法，都会一次将所有结果获取到，这在数据量很大时将会消耗大量内存，所以有考虑是否还有别的方法，比如<code>one-by-one</code>的迭代获取。</p>
<p>在查看<code>DictCursor</code>游标代码时，发现了<code>SSCursor</code>游标类，其注释如下，意在解决数据量大的问题，正合我意。</p>
<a id="more"></a>
<figure class="highlight mizar"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class SSCursor(Cursor):</div><div class="line">    """</div><div class="line">    Unbuffered Cursor, mainly useful <span class="keyword">for</span> queries <span class="keyword">that</span> return a lot <span class="keyword">of</span> data,</div><div class="line">    <span class="keyword">or</span> <span class="keyword">for</span> connections to remote servers over a slow network.</div><div class="line"></div><div class="line">    Instead <span class="keyword">of</span> copying every row <span class="keyword">of</span> data into a buffer, this will fetch</div><div class="line">    rows <span class="keyword">as</span> needed. The upside <span class="keyword">of</span> this, <span class="keyword">is</span> the client uses much less memory,</div><div class="line">    <span class="keyword">and</span> rows are returned much faster when traveling over a slow network,</div><div class="line">    <span class="keyword">or</span> if the result <span class="keyword">set</span> <span class="keyword">is</span> very big.</div><div class="line"></div><div class="line">    There are limitations, though. The MySQL protocol doesn't support</div><div class="line">    returning the total number <span class="keyword">of</span> rows, so the only way to tell how many rows</div><div class="line">    there are <span class="keyword">is</span> to iterate over every row returned. Also, it currently isn't</div><div class="line">    possible to scroll backwards, <span class="keyword">as</span> only the current row <span class="keyword">is</span> held <span class="keyword">in</span> memory.</div><div class="line">    """</div></pre></td></tr></table></figure>
<p><code>DictCursor</code>游标类的方法返回都是一个迭代器，可以使用这个迭代器进行迭代获取，这样就不用一次将所有数据保存在内存中了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchall_unbuffered</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Fetch all, implemented as a generator, which isn't to standard,</div><div class="line">    however, it doesn't make sense to return everything in a list, as that</div><div class="line">    would use ridiculous memory for large result sets.</div><div class="line">    """</div><div class="line">    <span class="keyword">return</span> iter(self.fetchone, <span class="keyword">None</span>)</div></pre></td></tr></table></figure>
<p>使用方法如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import pymysql.cursors</div><div class="line">src_pc_database = pymysql.connect(host=<span class="string">'192.168.39.51'</span>, port=<span class="number">5151</span>, user=<span class="string">'*'</span>, password=<span class="string">'*'</span>,</div><div class="line">                               db=<span class="string">'testdataanalyse'</span>,</div><div class="line">                               charset=<span class="string">'utf8mb4'</span>, cursorclass=pymysql.cursors.SSDictCursor)</div><div class="line"></div><div class="line"><span class="keyword">with</span> src_pc_database.cursor() <span class="keyword">as</span> src_cursor:</div><div class="line">    sql = <span class="string">"select * from user"</span></div><div class="line">    src_cursor.execute(sql)</div><div class="line">    <span class="built_in">result</span> = src_cursor.fetchone()</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> <span class="built_in">result</span> is <span class="keyword">not</span> None:</div><div class="line">        <span class="built_in">result</span> = src_cursor.fetchone()</div><div class="line"></div><div class="line">src_pc_database.<span class="built_in">close</span>()</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS相关tips]]></title>
      <url>https://zhongwuzw.github.io/2016/10/10/iOS%E7%9B%B8%E5%85%B3tips/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><hr>
<ul>
<li><p>iOS8.3之后，通过iTunes、iFunBox等工具已无法直接访问应用的沙盒，如果需要让自己的应用能够通过其访问，必须在应用的<code>info.plist</code>中添加<code>UIFileSharingEnabled</code>关键字，并赋值为<code>YES</code>，这样，就能访问其<code>Documents</code>目录了(注意，其它目录还是无法访问)。</p>
</li>
<li><p>使用<code>UIWebView</code>时，发现在首次加载网页时，加载时间异常的长，其原因是服务器需要花费一定的时间来解析请求来自于哪个平台，比如<code>PC</code>、<code>iPhone</code>、<code>iPad</code>等，以针对不同的平台响应不同的页面布局，解决该问题的方法为客户端直接请求特定版本的页面，且设置请求的<code>UA</code>(<code>User Agent</code>)，如下代码：</p>
  <figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[NSUserDefaults standardUserDefaults] registerDefaults:@&#123;@<span class="string">"UserAgent"</span> : @<span class="string">"    Mozilla/5.0 (iPhone; CPU iPhone OS 10_0 like Mac OS X) AppleWebKit/602.1.38 (KHTML, like Gecko) Version/10.0 Mobile/14A300 Safari/602.1"</span>&#125;]<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
<li><p>在使用<code>UIBarButtonItem</code>，并对其使用<code>UIImage</code>赋值时，iOS7之后会对<code>UIImage</code>设置<code>tintColor</code>，从而改变图片的原值色，如果需要保留图片原色，可以对<code>UIImage</code>进行如下代码设置：</p>
  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UIImage *<span class="built_in">image</span> = [UIImage imageNamed:@<span class="string">"myImage.png"</span>];</div><div class="line"><span class="built_in">image</span> = [<span class="built_in">image</span> imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];</div></pre></td></tr></table></figure>
<a id="more"></a>
</li>
</ul>
<ul>
<li><p>iOS7之后，对于<code>UIViewController</code>的内容布局，默认会从屏幕顶部开始，这就会导致内容被状态栏所覆盖。<br> 如果<code>UIViewController</code>包含在<code>UINavigationController</code>下且<code>navigationBar</code>是可见的，那么可以使用如下代码来使内容布局不被状态栏覆盖：</p>
  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.edgesForExtendedLayout = <span class="built_in">UIRectEdgeNone</span>;</div></pre></td></tr></table></figure>
<p>  如果<code>navigationBar</code>不可见，那么就只能调整<code>UIVew</code>的位置了，向下移20 points。</p>
</li>
<li><p><code>UIWebView</code>加载页面时底部出现黑条问题解决方法：设置<code>UIWebView</code>的<code>backgroundColor</code>为<code>clearColor</code>，<code>opaque</code>为<code>NO</code>即可。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[修改Nginx的网站根目录]]></title>
      <url>https://zhongwuzw.github.io/2016/09/24/%E8%B0%83%E6%95%B4Nginx%E7%9A%84%E7%BD%91%E7%AB%99%E6%A0%B9%E7%9B%AE%E5%BD%95/</url>
      <content type="html"><![CDATA[<h2 id="修改Nginx的网站根目录"><a href="#修改Nginx的网站根目录" class="headerlink" title="修改Nginx的网站根目录"></a>修改Nginx的网站根目录</h2><hr>
<p>Nginx的默认网站文件保存在<code>nginx</code>的<code>html</code>目录下，由于我开发时都把项目放在自己的<code>workspace</code>里，所以准备更改网站根目录，更改方法为修改<code>nginx.conf</code>配置文件的<code>root</code>指令，<code>root</code>指令可以放在<code>http</code>、<code>server</code>、<code>location</code>块中，我选择把<code>root</code>指令放在<code>server</code>块中，如下所示：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class">http </span>&#123;</div><div class="line">    include       mime.types;</div><div class="line">    default_type  application/octet-stream;</div><div class="line"></div><div class="line">    <span class="meta">#access_log  logs/access.log  main;</span></div><div class="line"></div><div class="line">    sendfile        on;</div><div class="line">    <span class="meta">#tcp_nopush     on;</span></div><div class="line">    </div><div class="line">    keepalive_timeout  <span class="number">65</span>;</div><div class="line"></div><div class="line">    <span class="meta">#gzip  on;</span></div><div class="line"></div><div class="line">    <span class="class">server </span>&#123;</div><div class="line">        listen       <span class="number">80</span>;</div><div class="line">        server_name  localhost;</div><div class="line">        <span class="comment">//配置root指令</span></div><div class="line">        root /Users<span class="meta-keyword">/zhongwu/</span>Documents<span class="meta-keyword">/workspace/</span>web;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>配置完成后，执行<code>sudo ./nginx -s reload</code>命令，Nginx支持动态更新配置信息。</p>
<p>访问一下网页测一下，发现返回状态码403，既请求被服务器拒绝了，查看Nginx的<code>error.log</code>后，发现如下log，既Nginx没有打开该html文件的权限，所以得解决权限的问题。</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2016</span>/<span class="number">09</span>/<span class="number">24</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">39</span> <span class="string">[error]</span> <span class="number">16397</span>#<span class="number">0</span>: *<span class="number">15</span> open() <span class="string">"/Users/zhongwu/Documents/workspace/web/lounge.html"</span> failed (<span class="number">13</span>: Permission denied), client: <span class="number">127.0.0.1</span>, server: localhost, request: <span class="string">"<span class="keyword">GET</span> /lounge.html HTTP/1.1"</span>, host: <span class="string">"127.0.0.1"</span></div></pre></td></tr></table></figure>
<p>首先我们来了解Nginx的用户权限，Nginx的<code>master</code>进程是<code>root</code>权限，而<code>worker</code>进程默认是<code>nobody</code>用户，用户组同为<code>nobody</code>，由于请求的处理是由<code>worker</code>进程处理的，所以，需要修改<code>worker</code>的用户，将其修改为我的<code>workspace</code>目录的用户，方法为直接修改Nginx配置文件，在<code>nginx.conf</code>配置文件中添加<code>user  zhongwu staff;//zhongwu是我的workspace用户，staff是用户组</code>。<br>再访问以下，成功。</p>
<h2 id="解决127-0-0-1能访问，而localhost不能访问"><a href="#解决127-0-0-1能访问，而localhost不能访问" class="headerlink" title="解决127.0.0.1能访问，而localhost不能访问"></a>解决127.0.0.1能访问，而localhost不能访问</h2><hr>
<p>项目出现127.0.0.1能访问，而localhost却访问不了的问题，定位，应该是<code>dns</code>域名解析的问题，查看<code>/etc/hosts</code>文件，发现有一条记录为：<code>::1 localhost</code>，<code>::1</code>是<code>ipv6</code>的表示方法，将其改为<code>ipv4</code>的，既将<code>::1</code>替换为<code>127.0.0.1</code>，因为Nginx默认并没有开启监听<code>ipv6</code>地址。</p>
<p>再次访问，localhost就能访问了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS获取通话记录]]></title>
      <url>https://zhongwuzw.github.io/2016/09/22/iOS%E8%8E%B7%E5%8F%96%E9%80%9A%E8%AF%9D%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p><code>iOS8.3</code>之后，存放通话日志的数据库的位置换成了<code>/private/var/mobile/Library/CallHistoryDB/</code>目录，数据库名为<code>CallHistory.storedata</code>，由于其采用了<code>Sqlite</code>的<code>wal</code>机制，所以还有两个文件，分别为<code>CallHistory.storedata-shm</code>、<code>CallHistory.storedata-wal</code>,一开始想得很简单，直接使用<code>Sqlite</code>打开该数据库，读取即可，后来发现使用<code>NSFileManager</code>并不能获取到该文件。接下来将详细列出解决思路。</p>
<h2 id="读取通话日志文件"><a href="#读取通话日志文件" class="headerlink" title="读取通话日志文件"></a>读取通话日志文件</h2><hr>
<p>直接使用<code>NSFileManager</code>不能获取到通话日志文件的原因很简单，因为App本身是在一个沙盒里面的，App只能访问自己的存储空间，系统有一套安全机制来对其进行限制。所以，首先得解决这个限制，解决方案是添加Entitlements授权，在Entitlements文件中添加如下代码：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="params">&lt;key&gt;</span>com.apple.security.exception.files.absolute-path.read-write<span class="params">&lt;/key&gt;</span></div><div class="line"><span class="params">&lt;array&gt;</span></div><div class="line">	<span class="params">&lt;string&gt;</span><span class="meta-keyword">/private/</span>var<span class="meta-keyword">/mobile/</span>Library/CallHistoryDB/CallHistory.storedata-wal<span class="params">&lt;/string&gt;</span></div><div class="line">	<span class="params">&lt;string&gt;</span><span class="meta-keyword">/private/</span>var<span class="meta-keyword">/mobile/</span>Library/CallHistoryDB/CallHistory.storedata-shm<span class="params">&lt;/string&gt;</span></div><div class="line">	<span class="params">&lt;string&gt;</span><span class="meta-keyword">/private/</span>var<span class="meta-keyword">/mobile/</span>Library/CallHistoryDB/CallHistory.storedata<span class="params">&lt;/string&gt;</span></div><div class="line"><span class="params">&lt;/array&gt;</span></div></pre></td></tr></table></figure>
<p>这样，就能访问到通话日志文件。</p>
<h2 id="使用Sqlite读取数据库"><a href="#使用Sqlite读取数据库" class="headerlink" title="使用Sqlite读取数据库"></a>使用<code>Sqlite</code>读取数据库</h2><hr>
<p>使用<code>Sqlite</code>直接读取数据库内容时，发现，在调用<code>int errorCode = sqlite3_prepare_v2(database,[sqlStatement UTF8String],-1,&amp;compiledStatement, NULL);</code>时，出现错误，错误代码为<code>SQLITE_AUTH</code>，既没有权限，最后解决方案是，将3个文件内容读出，并保存到App自己的存储空间中，比如<code>Cache</code>目录中，再对保存到App存储目录中的数据库文件进行操作即可。</p>
<h2 id="解决wal模式问题"><a href="#解决wal模式问题" class="headerlink" title="解决wal模式问题"></a>解决<code>wal</code>模式问题</h2><hr>
<p>由于通话日志的数据库采用了新的事务设计<code>wal</code>（write-ahead logging），数据库修改后，首先会把修改内容写入日志（-wal），为了提高性能创建了一个内存索引（-shm），映射每一个page是否dirty，读取时先看需要的page是否在<code>wal</code>日志中，然后再读取，当达到一定条件后Sqlite会自动将数据flush到数据库文件，当然也可以手动flush，在打开数据库之后，调用<code>sqlite3_wal_checkpoint(database, NULL);</code>即可手动flush</p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><hr>
<p>解决这几个问题后，就能成功读取通话日志了，其他的日志，如短信等等同理都可以读取到。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[epoll的两种工作模式]]></title>
      <url>https://zhongwuzw.github.io/2016/09/21/epoll%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p><code>epoll</code>是<code>Linux</code>下的一个多路复用API，当处理大并发的事件时，其性能远强于古老的<code>poll</code>和<code>select</code>。<code>epoll</code>可以工作在两种模式下，<code>LT</code>（水平触发）、<code>ET</code>（边缘触发），接下来将讨论这两种模式的区别。</p>
<h2 id="ET（边缘触发）和LT（水平触发）"><a href="#ET（边缘触发）和LT（水平触发）" class="headerlink" title="ET（边缘触发）和LT（水平触发）"></a><code>ET</code>（边缘触发）和<code>LT</code>（水平触发）</h2><hr>
<p>默认情况下，<code>epoll</code>采用<code>LT</code>模式工作，该模式支持阻塞和非阻塞套接字，如果想采用<code>ET</code>模式，可以使用<code>EPOLLET</code>参数。<code>ET</code>模式只支持非阻塞套接字，其效率要高于<code>LT</code>模式，两者的区别在于，当一个新的事件到来时，<code>LT</code>、<code>ET</code>模式下都可以通过<code>epoll_wait</code>方法来获取到这个事件，但是如果这次没有把这个事件对应的套接字缓冲区处理完，在这个套接字没有新的事件再次到来时，在<code>ET</code>模式下是无法再次从<code>epoll_wait</code>方法中获取到这个事件的；而<code>LT</code>模式则可以再次获取到，进而再次进行处理，其只要一个事件对应的套接字缓冲区还有数据，就总能从<code>epoll_wait</code>中获取到这个事件，因此，如果采用<code>ET</code>模式进行开发时，要特别注意，如果没有彻底的将缓冲区中的数据处理完，则会导致缓冲区中的用户请求得不到响应。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Nginx的架构设计]]></title>
      <url>https://zhongwuzw.github.io/2016/09/18/Nginx%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<h2 id="Nginx架构概述"><a href="#Nginx架构概述" class="headerlink" title="Nginx架构概述"></a>Nginx架构概述</h2><hr>
<p>传统基于进程或线程的模型（<code>Apache</code>就采用这种模型）在处理并发连接时会为每一个连接建立一个单独的进程或线程，且在网络或者输入/输出操作时阻塞。这将导致内存和<code>CPU</code>的大量消耗，因为新起一个单独的进程或线程需要准备新的运行时环境，包括堆和栈内存的分配，以及新的执行上下文，当然，这些也会导致多余的<code>CPU</code>开销。最终，会由于过多的上下文切换而导致服务器性能变差。<br>反过来，我们来看Nginx的架构设计，总结起来，它是模块化的、基于事件驱动、异步、单线程且非阻塞。<br>Nginx大量使用多路复用和事件通知，Nginx会创建几个数量有限（比如<code>worker</code>的数量和<code>CPU</code>的核数相同）的<code>worker</code>进程，每个<code>worker</code>进程包含一个高效的Run-loop，来处理多个网络连接，每个<code>worker</code>进程每秒能处理成千的并发连接。</p>
<h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p><code>worker</code>进程负责维护Run-loop，并且在请求处理的每个阶段执行相应模块代码，Nginx包括很多模块，如事件模块，状态处理模块，协议模块，负载均衡等。Nginx并不支持动态加载模块，模块只能在Nginx编译时进行添加进来。<br>在接收，处理和管理网络请求时，Nginx会根据操作系统的不同，采用特定的事件模型和磁盘<code>I/O</code>，以达到更高的性能，如<code>Linux</code>，<code>Solaris</code>以及基于<code>BSD</code>的操作系统，采用<code>epoll</code>，<code>kqueue</code>，<code>event ports</code>。<br>Nginx的架构图如下：<br><img src="http://oc54pu02q.bkt.clouddn.com/QQ20160918-0@2x.png" alt=""></p>
 <a id="more"></a>
<h3 id="Worker模型"><a href="#Worker模型" class="headerlink" title="Worker模型"></a>Worker模型</h3><p>前面提到，Nginx并不会为每一个连接新建一个进程来进行处理，相反，<code>worker</code>会从一个共享的监听套接字中获取新的请求，并在<code>worker</code>管理的Run-loop中处理请求。Nginx启动时，将创建初始的监听套接字，接下来，当<code>worker</code>处理<code>HTTP</code>请求和响应时，会持续的接收、读取、以及写入套接字。<br>Run-loop是<code>worker</code>的核心，它的主要思想是异步任务处理，实现方式包括模块化、事件通知、回调函数、定时器等。总的原则就是尽可能的非阻塞。<br>关于<code>worker</code>的数量问题，通常的建议是：</p>
<ul>
<li>CPU密集型：比如处理大量的TCP/IP，SSL，或压缩时，Nginx <code>worker</code>进程的数量应当和CPU核的数量一致。</li>
<li>磁盘I/O密集型：提供文件内容，或者大量的代理，这种情况下，<code>worker</code>进程的数量可以是CPU核数的1.5或2倍。</li>
</ul>
<h3 id="Nginx进程职责"><a href="#Nginx进程职责" class="headerlink" title="Nginx进程职责"></a>Nginx进程职责</h3><p>Nginx运行时会有多个进程，包括一个<code>master</code>进程和多个<code>worker</code>进程，除此之外，还包括一对特定作用的进程，<code>cache loader</code>进程和<code>cache manager</code>进程。所有的进程都是单线程（即只有一个主线程）的，且进程间通信主要使用共享内存的方式。<code>master</code>进程以<code>root</code>用户权限运行，其它进程则以非<code>root</code>方式运行。<br><code>master</code>进程主要负责如下的任务：</p>
<ul>
<li>读取和诊断配置文件</li>
<li>创建、绑定以及关闭套接字</li>
<li>启动、终止和管理<code>worker</code>进程</li>
<li>无须重启即可动态更新配置</li>
<li>平滑升级</li>
<li>重新打开log文件</li>
<li>编译内嵌的<code>Perl</code>脚本</li>
</ul>
<p><code>worker</code>进程接收、处理连接请求，提供反向代理和过滤以及其它的功能。<br><code>cache loader</code>进程负责检测磁盘的缓存，且向内存数据库提供缓存元数据，<code>cache loader</code>在Nginx准备启动时，以一定的目录结构，遍历缓存内容的元数据，更新共享内存中的相关条目，当准备完成后退出。<br><code>cache manager</code>进程主要负责缓存的过期管理和诊断。</p>
<h3 id="Nginx缓存简单介绍"><a href="#Nginx缓存简单介绍" class="headerlink" title="Nginx缓存简单介绍"></a>Nginx缓存简单介绍</h3><p>缓存的键和元数据存储在共享内存段中，<code>cache loader</code>、<code>cache manager</code>、<code>worker</code>进程可以对其进行访问。<br>将内容存入缓存的过程如下：<br>当Nginx从上游服务器读取响应时，响应内容首先会被写入到一个缓存文件中，当请求处理完成后，重命名缓存文件，并将它移到缓存的目录中。</p>
<h2 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h2><hr>
<p>Nginx的主配置文件名默认为<code>nginx.conf</code>，配置文件由<code>master</code>进程读取和诊断，读取完之后以一定的形式保存在内存中，当<code>worker</code>进程从<code>master</code>进程中<code>fork</code>时（<code>fork</code>之后，子进程是父进程的副本，子进程获得父进程数据空间、堆和栈的拷贝），<code>worker</code>进程就能够访问到这些配置数据。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS事件处理之Hit-Testing]]></title>
      <url>https://zhongwuzw.github.io/2016/09/12/iOS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E4%B9%8BHit-Testing/</url>
      <content type="html"><![CDATA[<hr>
<p>iOS中，Hit-Testing主要用于决定哪个视图来首先处理Touch事件，确定完后，就会依据响应者链来进行事件的处理。接下来，我们将分析Hit-Testing的工作流程。</p>
<blockquote>
<p>由于不确定的原因，Hit-Testing测试会被执行多次，导致单个视图的<code>-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</code>方法会被调用多次，由于是幂等的，所以结果不影响。</p>
</blockquote>
<p>Hit-Testing使用的搜索算法为<strong><em>逆前序深度遍历</em></strong>（逆前序遍历先访问根节点，然后进行从其索引最大的子视图到最小的子视图的遍历，既从右至左进行遍历）。当touch事件的points发生在多个视图的重叠部分时，根据算法将得到最右子树中的最深视图，而该视图就是位于界面最前端的视图。</p>
<p>下图展示了一个视图层级树以及对应在屏幕上的显示结果，树的分支顺序安排反应了子视图数组的顺序，比如<code>View A</code>的索引小于<code>View B</code>。<br><img src="http://oc54pu02q.bkt.clouddn.com/hit-test-view-hierarchy.png" alt=""></p>
 <a id="more"></a>
<p>由上图，<code>View A.2</code>和<code>View B.1</code>两个视图重叠了，但是因为<code>View B</code>和<code>View A</code>是兄弟视图，且<code>View B</code>的索引大于<code>View A</code>，因此，当用户的touch事件发生在<code>View A.2</code>和<code>View B.1</code>重叠的部分时，Hit-Testing将返回<code>View B.1</code>。</p>
<p>通过应用逆前序深度遍历算法，当找到第一个最深的后代视图满足后就会停止遍历。<br><img src="http://oc54pu02q.bkt.clouddn.com/hit-test-depth-first-traversal.png" alt=""></p>
<p>遍历算法是以向<code>UIWindow</code>发送<code>hitTest:withEvent</code>消息开始的，<code>UIWindow</code>是视图层级的根视图，<code>hitTest:withEvent</code>方法返回的值即是包含触摸点最前端的视图。<br>下图展示了Hit-Testing的逻辑：<br><img src="http://oc54pu02q.bkt.clouddn.com/hit-test-flowchart.png" alt=""><br>如下代码展示了原生<code>hitTest:withEvent:</code>方法可能的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.isUserInteractionEnabled || <span class="keyword">self</span>.isHidden || <span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> pointInside:point withEvent:event]) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> [<span class="keyword">self</span>.subviews reverseObjectEnumerator]) &#123;</div><div class="line">            <span class="built_in">CGPoint</span> convertedPoint = [subview convertPoint:point fromView:<span class="keyword">self</span>];</div><div class="line">            <span class="built_in">UIView</span> *hitTestView = [subview hitTest:convertedPoint withEvent:event];</div><div class="line">            <span class="keyword">if</span> (hitTestView) &#123;</div><div class="line">                <span class="keyword">return</span> hitTestView;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>hitTest:withEvent</code>方法首先检测视图是否允许接收touch事件，当如下条件满足时，既允许接收事件：</p>
<ul>
<li>视图没被隐藏：<br>  <code>self.hidden == NO</code></li>
<li>视图允许用户交互：<br>  <code>self.userInteractionEnabled = YES</code></li>
<li>视图的alpha值大于0.01：<br>  <code>self.alpha &gt; 0.01</code></li>
<li>touch事件的触摸点在视图的bounds内：<br>  <code>pointInside:withEvent: == YES</code></li>
</ul>
<p>当视图允许接收touch事件后，该方法将对其<code>subviews</code>子视图数组的每个视图，以逆序的方式，发送<code>hitTest:withEvent:</code>消息，直到返回非<code>nil</code>的值。当其子视图都返回<code>nil</code>或者没有子视图时，则返回视图本身。<br>如果视图不被允许接收touch事件，那么方法会返回<code>nil</code>，且不需要对视图的子树进行遍历。</p>
<h2 id="重载hitTest-withEvent-示例"><a href="#重载hitTest-withEvent-示例" class="headerlink" title="重载hitTest:withEvent:示例"></a>重载<code>hitTest:withEvent:</code>示例</h2><p>当默认的搜索算法不满足要求时，可以重载<code>hitTest:withEvent:</code>来自定义。</p>
<h3 id="增加视图的touch区域"><a href="#增加视图的touch区域" class="headerlink" title="增加视图的touch区域"></a>增加视图的touch区域</h3><p>当需要一个视图的touch区域大于它的bounds时，可以重载<code>hitTest:withEvent:</code>方法，比如，下面展示了一个20X20的视图<code>UIView</code>，该大小可能对于处理touch来说有点小，因此，可以通过重载<code>hitTest:withEvent:</code>方法来在每个方向上增加10points：<br><img src="http://oc54pu02q.bkt.clouddn.com/hit-test-increase-touch-area.png" alt=""></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.isUserInteractionEnabled || <span class="keyword">self</span>.isHidden || <span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">CGRect</span> touchRect = <span class="built_in">CGRectInset</span>(<span class="keyword">self</span>.bounds, <span class="number">-10</span>, <span class="number">-10</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(touchRect, point)) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> [<span class="keyword">self</span>.subviews reverseObjectEnumerator]) &#123;</div><div class="line">            <span class="built_in">CGPoint</span> convertedPoint = [subview convertPoint:point fromView:<span class="keyword">self</span>];</div><div class="line">            <span class="built_in">UIView</span> *hitTestView = [subview hitTest:convertedPoint withEvent:event];</div><div class="line">            <span class="keyword">if</span> (hitTestView) &#123;</div><div class="line">                <span class="keyword">return</span> hitTestView;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，该实现能正确执行的前提是，希望响应touch事件的区域必须在其父视图的bounds范围内，或者重写父视图的<code>hitTest:withEvent:</code>方法来包含能响应touch的区域。</p>
</blockquote>
<h3 id="将touch事件传到其下面的视图，既透传"><a href="#将touch事件传到其下面的视图，既透传" class="headerlink" title="将touch事件传到其下面的视图，既透传"></a>将touch事件传到其下面的视图，既透传</h3><p>有时我们需要一个视图忽略touch事件并把他们传到其下面的视图，比如，当touch的pints在视图的子视图时，返回子视图，否则将事件透传到下面的视图，代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    <span class="built_in">UIView</span> *hitTestView = [<span class="keyword">super</span> hitTest:point withEvent:event];</div><div class="line">    <span class="keyword">if</span> (hitTestView == <span class="keyword">self</span>) &#123;</div><div class="line">        hitTestView = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hitTestView;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="将touch事件传给子视图"><a href="#将touch事件传给子视图" class="headerlink" title="将touch事件传给子视图"></a>将touch事件传给子视图</h3><p>父视图对所有touch事件进行重定向，传到子视图中，比如，一个图片旋转功能，由一个父视图和一个<code>UIScrollView</code>组成，且设置<code>UIScrollView</code>视图的<code>pagingEnabled</code>属性为<code>YES</code>，且设置父视图的<code>clipsToBounds</code>属性为NO。<br><img src="http://oc54pu02q.bkt.clouddn.com/hit-test-pass-touches-to-subviews.png" alt=""><br>为了让<code>UIScrollView</code>不仅能够响应其bounds范围内的事件，同样也能响应其父视图的bounds内的事件，可以重载父视图的<code>hitTest:withEvent:</code>方法，代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    <span class="built_in">UIView</span> *hitTestView = [<span class="keyword">super</span> hitTest:point withEvent:event];</div><div class="line">    <span class="keyword">if</span> (hitTestView) &#123;</div><div class="line">        hitTestView = <span class="keyword">self</span>.scrollView;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hitTestView;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS越狱相关基础知识]]></title>
      <url>https://zhongwuzw.github.io/2016/09/11/iOS%E8%B6%8A%E7%8B%B1%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><hr>
<ul>
<li><code>dylib</code>的权限由它寄生的那个App决定，同一个<code>dylib</code>寄生在系统App和用户App里时的授权是不同的。</li>
<li>越狱之后，我们就可以拥有daemon的概念了，给用户提供各种“守护”。</li>
<li><a href="http://stevenygard.com/projects/class-dump/" target="_blank" rel="external">Class-dump</a>处理的对象是<code>Mach-O</code>格式的二进制文件，如<code>Framework</code>的库文件和App的可执行文件。</li>
<li>采用<code>arm64</code>架构的App不兼容<code>armv7/armv7s</code>架构。</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><hr>
<ul>
<li>查看app文件的可执行文件(对于<code>App Store</code>上下载的App，经过了加密，所以需要先砸壳才能获取到)：<code>plutil -p Info.plist | grep CFBundleExecutable</code></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[源码分析之SDWebImage]]></title>
      <url>https://zhongwuzw.github.io/2016/09/08/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BSDWebImage/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在iOS开发中，很多都使用到<a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a>库，该库使用了外观模式，提供简洁的API，<code>UIButton</code>、<code>UIImageView</code>等类可以直接调用API进行网络图片的下载，接下来，就来分析一下<code>SDWebImage</code>的整个工作流程。</p>
<h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><hr>
<p>查看<code>SDWebImage</code>的整个项目结构，除去一些辅助的类，其结构大致如下图所示，<code>UIView+WebCacheOperation</code>类作为<code>UIView</code>的类别，提供基本的方法，如设置、取消、移除<code>Operation</code>操作，该<code>Operation</code>满足<code>&lt;SDWebImageOperation&gt;</code>协议，并通过关联引用来进行存储。<br><code>UIImageView+WebCache</code>、<code>SDWebImageManager</code>等类提供对外的接口。<br><code>SDWebImageManager</code>类将作为Manager来进行下载和缓存的管理，而真正负责下载的类为<code>SDWebImageDownloader</code>类，<code>SDWebImageDownloaderOperation</code>负责封装下载对象；管理缓存的类为<code>SDImageCache</code>。<br>好了，大致结构就是这样，接下来将通过一次调用来分析其内部的具体流程。</p>
<p><img src="http://oc54pu02q.bkt.clouddn.com/%E6%9C%AA%E5%91%BD%E5%90%8D%202.png" alt=""></p>
<a id="more"></a>
<h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><hr>
<p>接下来，以设置<code>UIImageView</code>类的图片为例，我们将使用<code>UIImageView+WebCache</code>提供的API，其接口方法非常简便，你可以什么都不用管，直接调用<code>- (void)sd_setImageWithURL:(NSURL *)url</code>方法就能进行图片的赋值，<code>SDWebImageCache</code>库将自动根据默认配置进行下载和缓存。<br><code>UIImageView+WebCache</code>类提供的下载接口如下，每个接口方法只是参宿的个数不一样，不管是使用其中的哪个方法，最终都会等同于调用最后一个方法，其中缺省的参数会使用默认值。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)<span class="string">sd_setImageWithURL:</span>(NSURL *)url;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)<span class="string">sd_setImageWithURL:</span>(NSURL *)url <span class="string">placeholderImage:</span>(UIImage *)placeholder;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)<span class="string">sd_setImageWithURL:</span>(NSURL *)url <span class="string">placeholderImage:</span>(UIImage *)placeholder <span class="string">options:</span>(SDWebImageOptions)options;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)<span class="string">sd_setImageWithURL:</span>(NSURL *)url <span class="string">completed:</span>(SDWebImageCompletionBlock)completedBlock;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)<span class="string">sd_setImageWithURL:</span>(NSURL *)url <span class="string">placeholderImage:</span>(UIImage *)placeholder <span class="string">completed:</span>(SDWebImageCompletionBlock)completedBlock;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)<span class="string">sd_setImageWithURL:</span>(NSURL *)url <span class="string">placeholderImage:</span>(UIImage *)placeholder <span class="string">options:</span>(SDWebImageOptions)options <span class="string">completed:</span>(SDWebImageCompletionBlock)completedBlock;</div><div class="line"></div><div class="line"><span class="comment">//最终都会通过我来调用</span></div><div class="line">- (<span class="keyword">void</span>)<span class="string">sd_setImageWithURL:</span>(NSURL *)url <span class="string">placeholderImage:</span>(UIImage *)placeholder <span class="string">options:</span>(SDWebImageOptions)options <span class="string">progress:</span>(SDWebImageDownloaderProgressBlock)progressBlock <span class="string">completed:</span>(SDWebImageCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
<p>接下来，我们就来看一下方法的处理流程，代码如下所示:</p>
<ol>
<li>代码1：用来取消之前的图片加载。</li>
<li>代码2：当选项不包含<code>SDWebImageDelayPlaceholder</code>时，设置占位图片。</li>
<li>代码3：调用<code>SDWebImageManager</code>单例类的方法来进行图片的下载和缓存管理，该方法返回满足<code>&lt;SDWebImageOperation&gt;</code>协议的对象，在该方法的<code>completed</code>参数中，我们进行一些基本的操作，如将图片赋给<code>ImageView</code>等。</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="built_in">NSURL</span> *)url placeholderImage:(<span class="built_in">UIImage</span> *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123;</div><div class="line">    <span class="comment">//1</span></div><div class="line">    [<span class="keyword">self</span> sd_cancelCurrentImageLoad];</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line"></div><div class="line">    <span class="comment">//2</span></div><div class="line">    <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">        dispatch_main_async_safe(^&#123;</div><div class="line">            <span class="keyword">self</span>.image = placeholder;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (url) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// check if activityView is enabled or not</span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> showActivityIndicatorView]) &#123;</div><div class="line">            [<span class="keyword">self</span> addActivityIndicator];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</div><div class="line">        <span class="comment">//3</span></div><div class="line">        <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">            [wself removeActivityIndicator];</div><div class="line">            <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</div><div class="line">            dispatch_main_sync_safe(^&#123;</div><div class="line">                <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</div><div class="line">                <span class="comment">//不自动进行图片的赋值</span></div><div class="line">                <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)</div><div class="line">                &#123;</div><div class="line">                    completedBlock(image, error, cacheType, url);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</div><div class="line">                    wself.image = image;</div><div class="line">                    [wself setNeedsLayout];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">                        wself.image = placeholder;</div><div class="line">                        [wself setNeedsLayout];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</div><div class="line">                    completedBlock(image, error, cacheType, url);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;];</div><div class="line">        <span class="comment">//将operation通过关联引用存储到字典对象中进行管理</span></div><div class="line">        [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="string">@"UIImageViewImageLoad"</span>];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dispatch_main_async_safe(^&#123;</div><div class="line">            [<span class="keyword">self</span> removeActivityIndicator];</div><div class="line">            <span class="keyword">if</span> (completedBlock) &#123;</div><div class="line">                <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">-1</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Trying to load a nil url"</span>&#125;];</div><div class="line">                completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, url);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，我们再接着往下走，分析一下上面代码中调用的<code>- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url
                                         options:(SDWebImageOptions)options
                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock
                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock</code>方法，代码如下，由于原代码代码量较多，所以裁剪了一些简单的处理代码。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url</div><div class="line">                                         options:(SDWebImageOptions)options</div><div class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;</div><div class="line">    __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</div><div class="line">    __<span class="keyword">weak</span> SDWebImageCombinedOperation *weakOperation = operation;</div><div class="line"></div><div class="line">    <span class="built_in">BOOL</span> isFailedUrl = <span class="literal">NO</span>;</div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">        isFailedUrl = [<span class="keyword">self</span>.failedURLs containsObject:url];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//1</span></div><div class="line">    <span class="keyword">if</span> (url.absoluteString.length == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</div><div class="line">        dispatch_main_sync_safe(^&#123;</div><div class="line">            <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorFileDoesNotExist</span> userInfo:<span class="literal">nil</span>];</div><div class="line">            completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, <span class="literal">YES</span>, url);</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span> operation;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">        [<span class="keyword">self</span>.runningOperations addObject:operation];</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</div><div class="line"></div><div class="line">    <span class="comment">//2</span></div><div class="line">    operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryDiskCacheForKey:key done:^(<span class="built_in">UIImage</span> *image, SDImageCacheType cacheType) &#123;</div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">                [<span class="keyword">self</span>.runningOperations removeObject:operation];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//3</span></div><div class="line">        <span class="keyword">if</span> ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url])) &#123;</div><div class="line">            <span class="keyword">if</span> (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">                dispatch_main_sync_safe(^&#123;</div><div class="line">                    <span class="comment">// If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span></div><div class="line">                    <span class="comment">// AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span></div><div class="line">                    completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//配置项的赋值</span></div><div class="line">            <span class="comment">// download if no image or requested to refresh anyway, and download allowed by delegate</span></div><div class="line">            SDWebImageDownloaderOptions downloaderOptions = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</div><div class="line">            <span class="keyword">if</span> (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</div><div class="line">            <span class="comment">//4</span></div><div class="line">            <span class="keyword">if</span> (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">                <span class="comment">// force progressive off if image already cached but forced refreshing</span></div><div class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</div><div class="line">                <span class="comment">// ignore image read from NSURLCache if image if cached but force refreshing</span></div><div class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//5</span></div><div class="line">            <span class="keyword">id</span> &lt;SDWebImageOperation&gt; subOperation = [<span class="keyword">self</span>.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                <span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//6</span></div><div class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageRetryFailed)) &#123;</div><div class="line">                        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">                            [<span class="keyword">self</span>.failedURLs removeObject:url];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                    <span class="built_in">BOOL</span> cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) &#123;</div><div class="line">                        <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//7</span></div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:transformDownloadedImage:withURL:)]) &#123;</div><div class="line">                        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</div><div class="line">                            <span class="comment">//调用委托方法来获得transform后的图片</span></div><div class="line">                            <span class="built_in">UIImage</span> *transformedImage = [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> transformDownloadedImage:downloadedImage withURL:url];</div><div class="line"></div><div class="line">                            <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</div><div class="line">                                <span class="built_in">BOOL</span> imageWasTransformed = ![transformedImage isEqual:downloadedImage];</div><div class="line">                                <span class="comment">//进行图片的缓存</span></div><div class="line">                                [<span class="keyword">self</span>.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? <span class="literal">nil</span> : data) forKey:key toDisk:cacheOnDisk];</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            dispatch_main_sync_safe(^&#123;</div><div class="line">                                <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                                    completedBlock(transformedImage, <span class="literal">nil</span>, SDImageCacheTypeNone, finished, url);</div><div class="line">                                &#125;</div><div class="line">                            &#125;);</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">                            <span class="comment">//进行图片缓存</span></div><div class="line">                            [<span class="keyword">self</span>.imageCache storeImage:downloadedImage recalculateFromImage:<span class="literal">NO</span> imageData:data forKey:key toDisk:cacheOnDisk];</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        dispatch_main_sync_safe(^&#123;</div><div class="line">                            <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                                completedBlock(downloadedImage, <span class="literal">nil</span>, SDImageCacheTypeNone, finished, url);</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (finished) &#123;</div><div class="line">                    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">                        <span class="keyword">if</span> (strongOperation) &#123;</div><div class="line">                            [<span class="keyword">self</span>.runningOperations removeObject:strongOperation];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            <span class="comment">//取消的Block，当取消操作执行时调用</span></div><div class="line">            operation.cancelBlock = ^&#123;</div><div class="line">                [subOperation cancel];</div><div class="line">                </div><div class="line">                <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">                    __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                    <span class="keyword">if</span> (strongOperation) &#123;</div><div class="line">                        [<span class="keyword">self</span>.runningOperations removeObject:strongOperation];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//找到缓存图片时调用</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</div><div class="line">            dispatch_main_sync_safe(^&#123;</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</div><div class="line">                    completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="comment">//移除操作对象</span></div><div class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">                [<span class="keyword">self</span>.runningOperations removeObject:operation];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>代码1用来判断请求的URL是否包含在失败的URL列表中，如果包含，且请求没有设置重试选项，则直接返回，不再进行接下来的流程。</li>
<li>接下来，着重看一下代码2部分，该操作是给<code>operation</code>的<code>cacheOperation</code>属性赋值，调用<code>SDImageCache</code>类的<code>- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock</code>方法，该方法将查询是否在硬盘或者内存中已经存在该图片，查询完之后调用<code>done</code>完成块，接下来看一下<code>done</code>完成块中的操作。</li>
<li>代码3的<code>if</code>判断满足条件为：没有找到缓存的image，或者有需要刷新缓存<br>的选项且调用的委托方法返回<code>True</code>。</li>
<li>代码4：当image存在，且选项包含<code>SDWebImageRefreshCached</code>时，去掉下载选项中的<code>SDWebImageDownloaderProgressiveDownload</code>选项，既移除<code>progresive</code>功能，该功能可以在图片下载的过程中渐进式的展示图片；除此之外，再把<code>SDWebImageDownloaderIgnoreCachedResponse</code>选项加到下载选项中，该选项忽略<code>NSURLCache</code>的缓存（使用<code>SDWebImageCache</code>库作请求图片时默认是不使用<code>NSURLCache</code>缓存的），关于<code>NSURLCache</code>，可参考<a href="http://nshipster.cn/nsurlcache/" target="_blank" rel="external">NSURLCache</a></li>
<li>代码5：创建一个下载图片的操作，调用<code>SDWebImageDownloader</code>类的<code>- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock</code>方法，先来看一下<code>completed</code>完成块的操作，先假设下载操作完成。</li>
<li>代码6：如果下载选项包括错误重试时，将URL从错误URL列表中移除。</li>
<li>代码7：如果下载图片时有用到transform，将进入该if块，接着会调用委托来让我们进行相应的transform，之后将调用<code>SDImageCache</code>类来进行图片的缓存。</li>
</ol>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>接下来，分析一下<code>SDImageCache</code>类的工作流程，<code>SDImageCache</code>类负责图片的缓存管理，缓存包括内存、硬盘两种缓存方式：</p>
<ul>
<li>内存缓存：使用<code>NSCache</code>类，通过监听内存警告的通知，在得到通知后移除<code>NSCache</code>类中保存的数据。</li>
<li>硬盘缓存：既将图片作为文件保存到硬盘上，关于图片过期的问题，<code>SDImageCache</code>类的处理方式是：监听App的状态，当进入后台运行时，将开启一个后台任务，对硬盘上保存的图片进行清理，这个过程包含两个操作（具体代码可参见<code>SDImageCache</code>类的<code>- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock</code>方法）：<ul>
<li>移除过期的文件。</li>
<li>当缓存的文件大小已经操作最大缓存大小时，将移除文件更新时间最老的图片文件，直到小于最大缓存为止。</li>
</ul>
</li>
</ul>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>图片的下载使用的<code>NSOperationQueue</code>来实现，它的好处就是可以cacel，且可以添加依赖，<code>SDWebImage</code>除了默认的<code>FIFO</code>先进先出策略外，还提供<code>LIFO</code>的策略，既后进先出，先执行后加入的下载操作，这个策略就是通过依赖来完成的。<br>下载操作被封装在<code>SDWebImageDownloaderOperation</code>对象中，<code>SDWebImageDownloaderOperation</code>继承自<code>NSOperation</code>类。<br>图片的下载使用的<code>NSURLSession</code>，通过实现<code>NSURLSession</code>相关的委托协议，来实现Progress的调用、协议认证等操作。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>SDWebImage</code>库整体结构还是很清晰的。对网络部分比较感兴趣的可以读一下源码。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS越狱设备添加Entitlements授权]]></title>
      <url>https://zhongwuzw.github.io/2016/09/05/iOS%E6%8E%88%E6%9D%83%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h2 id="在iOS越狱设备上添加Entitlements授权"><a href="#在iOS越狱设备上添加Entitlements授权" class="headerlink" title="在iOS越狱设备上添加Entitlements授权"></a>在iOS越狱设备上添加Entitlements授权</h2><p>院里的一款用于网络测试的APP，在iOS8.3之前，可以通过引入CoreTelephony框架，调用其私有函数来获取信号强度，MCC、MNC等相关参数，但在iOS8.3之后，无法通过私有API进行获取，APP开发团队一直没解决，Boss找到我，让我研究一下，看有没有解决方案，遂开始研究。<br>首先，经过多方的调研，发现在iOS8.3 above的系统是有解决方案的，参见<a href="http://stackoverflow.com/questions/13399659/get-cellid-mcc-mnc-lac-and-network-in-ios-5-1" target="_blank" rel="external">Stackoverflow</a>，大概思路是需要添加<code>Entitlements</code>授权，既在entitlements文件中添加如下的key，但是由于Apple 的<code>CodeSign</code>的机制，导致无法添加私有的<code>Entitlements</code>授权，所以需要绕过Apple的签名机制。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.CommCenter.fine-grained<span class="tag">&lt;/<span class="name">key</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>spi<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="绕过签名机制"><a href="#绕过签名机制" class="headerlink" title="绕过签名机制"></a>绕过签名机制</h2><p>一开始，使用ldid来进行签名，签名之后会导致app闪退，遂使用了另外一种方法，禁用codesign，采用伪证书的方式，接下来将详细列出步骤。</p>
<a id="more"></a>
<h2 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h2><ol>
<li>设备必须越狱，这是前提，且在Cydia中安装<code>AppSync Unified</code>插件（该插件需要添加软件源，地址为：<a href="http://cydia.angelxwind.net/" target="_blank" rel="external">http://cydia.angelxwind.net/</a>）。</li>
<li>Apple Developer的账号，免费的就行。</li>
<li><p>装完Xcode之后，执行如下命令，作用是禁用Xcode的CodeSign机制，然后允许进行AD_HOC签名。</p>
 <figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo defaults <span class="keyword">write</span> <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneOS.sdk/</span>SDKSettings.plist DefaultProperties -dict-add CODE_SIGNING_REQUIRED -string NO</div><div class="line">sudo defaults <span class="keyword">write</span> <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneOS.sdk/</span>SDKSettings.plist DefaultProperties -dict-add ENTITLEMENTS_REQUIRED -string NO</div><div class="line">sudo defaults <span class="keyword">write</span> <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneOS.sdk/</span>SDKSettings.plist DefaultProperties -dict-add AD_HOC_CODE_SIGNING_ALLOWED -string YES</div><div class="line">sudo chmod <span class="number">644</span> <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneOS.sdk/</span>SDKSettings.plist</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>打开Xcode，进行完初始化之后，退出即可。</li>
<li>打开Mac上的钥匙串访问应用，点击菜单栏上的<code>钥匙串访问-证书助理-创建证书</code>，在弹出的框中的证书类型选择<code>代码签名</code>，并勾选<code>让我覆盖这些默认值</code>，然后一路往下走，完成后就创建了一个新的证书。</li>
<li><p>在开发的项目中添加<code>Entitlements</code>文件，代码如下，其中，key为<code>com.apple.CommCenter.fine-grained</code>的节点是我的项目需要添加的key，别的项目可忽略该键值，并添加自己需要的键值对：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">	<span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>get-task-allow<span class="tag">&lt;/<span class="name">key</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">true</span>/&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>application-identifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>$(AppIdentifierPrefix)$(CFBundleIdentifier)<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.CommCenter.fine-grained<span class="tag">&lt;/<span class="name">key</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>spi<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>在项目<code>Build Settings</code>设置的Code Signing部分，将<code>Code Signing Entitlements</code>设为Entilements文件名，然后将<code>Code Signing Identity</code>设为<code>Ad Hoc Code Sign</code>,如果项目包含多个target，则需要进行同样的设置。</p>
</li>
<li>完成。</li>
</ol>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul>
<li>ldid授权命令：<code>ldid -Sentitlements.xml OTS_SDK_3.1.app/OTS_SDK_3.1</code></li>
<li>ldid查看授权：<code>ldid -e OTS_SDK_3.1.app/OTS_SDK_3.1</code></li>
<li>codesign查看权限：<code>codesign -d --entitlements - Example.app</code></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://stackoverflow.com/questions/13399659/get-cellid-mcc-mnc-lac-and-network-in-ios-5-1" target="_blank" rel="external">http://stackoverflow.com/questions/13399659/get-cellid-mcc-mnc-lac-and-network-in-ios-5-1</a></li>
<li><a href="http://iphonedevwiki.net/index.php/Ldid" target="_blank" rel="external">http://iphonedevwiki.net/index.php/Ldid</a></li>
<li><a href="http://stackoverflow.com/questions/14871748/how-do-i-change-my-ios-applications-entitlements/14885266#14885266" target="_blank" rel="external">http://stackoverflow.com/questions/14871748/how-do-i-change-my-ios-applications-entitlements/14885266#14885266</a></li>
<li><a href="https://angelxwind.net/?page/how2asu" target="_blank" rel="external">https://angelxwind.net/?page/how2asu</a></li>
<li><a href="https://cydia.angelxwind.net/?page/net.angelxwind.appsyncunified" target="_blank" rel="external">https://cydia.angelxwind.net/?page/net.angelxwind.appsyncunified</a></li>
<li><a href="http://stackoverflow.com/questions/12768109/how-to-use-ldid" target="_blank" rel="external">http://stackoverflow.com/questions/12768109/how-to-use-ldid</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NSURLProtocol无法截获NSURLSession解决方案]]></title>
      <url>https://zhongwuzw.github.io/2016/08/31/NSURLProtocol%E6%97%A0%E6%B3%95%E6%88%AA%E8%8E%B7NSURLSession%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在做<a href="https://github.com/zhongwuzw/ZhihuDaily" target="_blank" rel="external">知乎日报</a>的项目时，在其设置界面中有一个选项，当开启时，可以在移动网络状况下不下载图片。这个需求的解决方案有两种，一种是在每一个使用网络图片的地方，在下载前进行判断，如果当前网络为移动蜂窝网络，且开启了<code>在移动网络状况下不下载图片</code>的选项时，放弃图片的下载；还有一种方案就是直接在<code>NSURLProtocol</code>中进行截获，在<code>+ (BOOL)canInitWithRequest:(NSURLRequest *)request</code>中进行判断，当<code>request.URL</code>请求为图片，并开启不下载图片选项，且当前为移动网络状况下，截获该请求。在<a href="https://github.com/zhongwuzw/ZhihuDaily" target="_blank" rel="external">知乎日报</a>项目中，我使用的第二种，既子类<code>NSURLProtocol</code>来实现请求拦截。</p>
<h2 id="NSURLProtocol实现图片下载拦截"><a href="#NSURLProtocol实现图片下载拦截" class="headerlink" title="NSURLProtocol实现图片下载拦截"></a>NSURLProtocol实现图片下载拦截</h2><p>一开始，觉得思路很简单，直接创建<code>PictureBlockURLProtocol</code>类，其是<code>NSURLProtocol</code>的子类,在<code>Implement</code>实现中定义如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取当前网络状态</span></div><div class="line">+ (<span class="built_in">BOOL</span>)isBlockPictureDownload&#123;</div><div class="line">    Reachability *reachability = ((AppDelegate *)[[<span class="built_in">UIApplication</span> sharedApplication] delegate]).reachability;</div><div class="line">    </div><div class="line">    NetworkStatus netStatus = [reachability currentReachabilityStatus];</div><div class="line">    </div><div class="line">    <span class="built_in">BOOL</span> isBlock = netStatus == ReachableViaWWAN?<span class="literal">YES</span> : <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> isBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([<span class="built_in">NSURLProtocol</span> propertyForKey:HybridResourceProtocolKey inRequest:request]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//满足条件时直接截获请求</span></div><div class="line">    <span class="keyword">if</span> ([[UserConfig sharedInstance] isBlockPicture] &amp;&amp; ([request.URL.pathExtension caseInsensitiveCompare:<span class="string">@"jpg"</span>] == <span class="built_in">NSOrderedSame</span> || [request.URL.pathExtension caseInsensitiveCompare:<span class="string">@"png"</span>] == <span class="built_in">NSOrderedSame</span>) &amp;&amp; [<span class="keyword">self</span> isBlockPictureDownload]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">NSURLRequest</span> *)canonicalRequestForRequest:(<span class="built_in">NSURLRequest</span> *)request</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> request;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//没有实现内容，request会以请求超时的方式结束</span></div><div class="line">- (<span class="keyword">void</span>)startLoading&#123;&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)stopLoading&#123;&#125;</div></pre></td></tr></table></figure>
 <a id="more"></a>
<p> 定义完<code>PictureBlockURLProtocol</code>类后，在<code>AppDelegate</code>类的<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>方法中调用<code>[NSURLProtocol registerClass:[PictureBlockURLProtocol class]]</code>方法进行注册，运行一下，看看效果，发现，当使用AFNetwork、SDWebImageCache等第三方库的图片请求并没有被截获到，而<code>UIWebView</code>可以，这就奇怪了，不过一想，<code>UIWebView</code>使用的是<code>NSURLConnection</code>，而<code>AFNetWork</code>、<code>SDWebCache</code>等已经废弃使用<code>NSURLConnection</code>，转而使用<code>NSURLSession</code>，难道是由于这个问题造成的？</p>
<p> 在查看<code>NSURLSession</code>相关类的文档时（如下图），从文档可以看到，如果需要支持自定义的<code>NSURLProtocol</code>，需要将自定义的<code>NSURLProtocol</code>子类赋给<code>NSURLSessionConfiguration</code>的<code>protocolClasses</code>属性。所以，如果需要<code>NSURLProtocol</code>来截获<code>NSURLSession</code>发出的请求，需要每一个<code>NSURLSession</code>在创建时配置的<code>NSURLSessionConfiguration</code>类的<code>protocolClasses</code>属性附上自定义的<code>NSURLProtocol</code>。<br>  <img src="http://oc54pu02q.bkt.clouddn.com/QQ20160831-0@2x.png" width="500" height="" alt="" align="center"></p>
<p> <em>根据上图的文档，注意到，对于后台Sessions，是不支持自定义的<code>NSURLProtocol</code>的。</em></p>
<p> 通过查看AFNetwork、SDWebImageCache的源代码，其创建的Session时关联的<code>NSURLSessionConfiguration</code>为<code>defaultSessionConfiguration</code>。这样，解决方案就有两种，一种是直接改AFNetwork、SDWebImageCache等库的源代码，在其创建的<code>NSURLSessionConfiguration</code>实例中将自定义的<code>NSURLProtocol</code>赋给其<code>protocolClasses</code>属性；另一种方案，使用Method Swizzling方法，由于AFNetwork、SDWebImageCache在创建时使用的是<code>[NSURLSessionConfiguration defaultSessionConfiguration]</code>，所以可以替换<code>defaultSessionConfiguration</code>实现。首先，创建<code>NSURLSessionConfiguration</code>的类别，代码如下：</p>
 <figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+ (NSURLSessionConfiguration *)zw_defaultSessionConfiguration&#123;</div><div class="line">    NSURLSessionConfiguration *configuration = [<span class="built_in">self</span> zw_defaultSessionConfiguration];</div><div class="line">    NSArray *protocolClasses = @[[PictureBlockURLProtocol <span class="class"><span class="keyword">class</span>]];</span></div><div class="line">    configuration.protocolClasses = protocolClasses;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> configuration;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)load&#123;</div><div class="line">    <span class="function"><span class="keyword">Method</span> <span class="title">systemMethod</span> =</span> class_getClassMethod([NSURLSessionConfiguration <span class="class"><span class="keyword">class</span>], @<span class="title">selector</span>(<span class="title">defaultSessionConfiguration</span>));</span></div><div class="line">    <span class="function"><span class="keyword">Method</span> <span class="title">zwMethod</span> =</span> class_getClassMethod([<span class="built_in">self</span> <span class="class"><span class="keyword">class</span>], @<span class="title">selector</span>(<span class="title">zw_defaultSessionConfiguration</span>));</span></div><div class="line">    method_exchangeImplementations(systemMethod, zwMethod);</div><div class="line">    </div><div class="line">    [NSURLProtocol registerClass:[PictureBlockURLProtocol <span class="class"><span class="keyword">class</span>]];</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 如上代码所示，在创建的每一个<code>NSURLSessionConfiguration</code>实例中，添加自定义的<code>NSURLProtocol</code>类到其<code>protocolClasses</code>属性，运行后，发现问题解决了，可以截获<code>NSURLSession</code>发出的请求了。</p>
<p> Done！！！！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[WebP图片格式iOS实例]]></title>
      <url>https://zhongwuzw.github.io/2016/08/26/WebP%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8FiOS%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>俗话说，谷歌大法好，<code>WebP</code>是由谷歌公司推出的图片文件格式，支持有损、无损压缩。从<a href="https://developers.google.com/speed/webp/" target="_blank" rel="external">官方文档</a>，可以看到如下图所示的对比，大意就是压缩率比PNG、JPEG等高。腾讯也对<code>WebP</code>做了测试，测试链接请戳<a href="http://isux.tencent.com/introduction-of-webp.html" target="_blank" rel="external">这里</a>。现在，很多公司都已经开始使用<code>WebP</code>格式，国内如腾讯、淘宝、今日头条等等。</p>
<p> <img src="http://oc54pu02q.bkt.clouddn.com/QQ20160826-0@2x.png" width="500" height="" alt="" align="center"></p>
<h1 id="iOS-WebP-示例"><a href="#iOS-WebP-示例" class="headerlink" title="iOS WebP 示例"></a>iOS WebP 示例</h1><p>iOS原生肯定是不支持<code>WebP</code>格式的，接下来，将介绍三种方法来展示在iOS端如何支持<code>WebP</code>格式：</p>
<h2 id="编译源代码"><a href="#编译源代码" class="headerlink" title="编译源代码"></a>编译源代码</h2><p>从官网下载<code>WebP</code>库的源代码，下载地址请戳<a href="https://developers.google.com/speed/webp/download" target="_blank" rel="external">这里</a>，下载如下图所示的部分，下载后是一个<code>tar</code>文件，名字类似于<br> <img src="http://oc54pu02q.bkt.clouddn.com/QQ20160826-1@2x.png" width="500" height="" alt="" align="center"><br> <code>libwebp-0.5.1.tar</code>，创建一个<code>build</code>文件夹，将该压缩文件放到<code>build</code>目录，然后再创建一个<code>build.sh</code>的shell文件，该文件用来生成通用的<code>framework</code>，代码如下：</p>
 <a id="more"></a>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">#!/bin/sh</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># <span class="doctag">Note:</span> This build script assumes it can find the archive for libwebp </span></div><div class="line"><span class="comment"># in the current directory. You can download it from the following URL:</span></div><div class="line"><span class="comment">#  http://code.google.com/speed/webp/download.html</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># The resulting framework will can be found in the current directory </span></div><div class="line"><span class="comment"># with the name WebP.framework</span></div><div class="line"><span class="comment">#</span></div><div class="line"></div><div class="line">SDK=9.3	<span class="comment">#改成自己的SDK版本</span></div><div class="line">PLATFORMS=<span class="string">"iPhoneSimulator iPhoneSimulator-64 iPhoneOS-V7 iPhoneOS-V7s iPhoneOS-ARM64"</span></div><div class="line">DEVELOPER=`xcode-select -print-path`</div><div class="line">TOPDIR=`<span class="built_in">pwd</span>`</div><div class="line">BUILDDIR=<span class="string">"<span class="variable">$TOPDIR</span>/tmp"</span></div><div class="line">FINALDIR=<span class="string">"<span class="variable">$TOPDIR</span>/WebP.framework"</span></div><div class="line">LIBLIST=<span class="string">''</span></div><div class="line">DEVROOT=<span class="string">"<span class="variable">$&#123;DEVELOPER&#125;</span>/Toolchains/XcodeDefault.xctoolchain"</span></div><div class="line"></div><div class="line">mkdir -p <span class="variable">$BUILDDIR</span></div><div class="line">mkdir -p <span class="variable">$FINALDIR</span></div><div class="line">mkdir <span class="variable">$FINALDIR</span>/Headers/</div><div class="line"></div><div class="line"><span class="keyword">for</span> PLATFORM <span class="keyword">in</span> <span class="variable">$&#123;PLATFORMS&#125;</span></div><div class="line"><span class="keyword">do</span></div><div class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;PLATFORM&#125;</span>"</span> == <span class="string">"iPhoneOS-V7"</span> ]</div><div class="line">  <span class="keyword">then</span></div><div class="line">    SDKPATH=<span class="string">"<span class="variable">$&#123;DEVELOPER&#125;</span>/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.3.sdk/"</span>	<span class="comment">#改成自己的SDK版本</span></div><div class="line">    ARCH=<span class="string">"armv7"</span></div><div class="line">    HOST=<span class="variable">$&#123;ARCH&#125;</span>-apple-darwin</div><div class="line">  <span class="keyword">elif</span> [ <span class="string">"<span class="variable">$&#123;PLATFORM&#125;</span>"</span> == <span class="string">"iPhoneOS-V7s"</span> ]</div><div class="line">  <span class="keyword">then</span></div><div class="line">    SDKPATH=<span class="string">"<span class="variable">$&#123;DEVELOPER&#125;</span>/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.3.sdk/"</span>	<span class="comment">#改成自己的SDK版本</span></div><div class="line">    ARCH=<span class="string">"armv7s"</span></div><div class="line">    HOST=<span class="variable">$&#123;ARCH&#125;</span>-apple-darwin</div><div class="line">  <span class="keyword">elif</span> [ <span class="string">"<span class="variable">$&#123;PLATFORM&#125;</span>"</span> == <span class="string">"iPhoneOS-ARM64"</span> ]</div><div class="line">  <span class="keyword">then</span></div><div class="line">    SDKPATH=<span class="string">"<span class="variable">$&#123;DEVELOPER&#125;</span>/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.3.sdk/"</span>	<span class="comment">#改成自己的SDK版本</span></div><div class="line">    ARCH=<span class="string">"arm64"</span></div><div class="line">    HOST=<span class="string">"aarch64-apple-darwin"</span></div><div class="line">  <span class="keyword">elif</span> [ <span class="string">"<span class="variable">$&#123;PLATFORM&#125;</span>"</span> == <span class="string">"iPhoneSimulator-64"</span> ]</div><div class="line">  <span class="keyword">then</span></div><div class="line">    SDKPATH=<span class="string">"<span class="variable">$&#123;DEVELOPER&#125;</span>/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator9.3.sdk/"</span>	<span class="comment">#改成自己的SDK版本</span></div><div class="line">    ARCH=<span class="string">"x86_64"</span></div><div class="line">    HOST=<span class="variable">$&#123;ARCH&#125;</span>-apple-darwin</div><div class="line">  <span class="keyword">else</span></div><div class="line">    SDKPATH=<span class="string">"<span class="variable">$&#123;DEVELOPER&#125;</span>/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator9.3.sdk/"</span>	<span class="comment">#改成自己的SDK版本</span></div><div class="line">    ARCH=<span class="string">"i386"</span></div><div class="line">    HOST=<span class="variable">$&#123;ARCH&#125;</span>-apple-darwin</div><div class="line">  <span class="keyword">fi</span></div><div class="line"></div><div class="line">  <span class="built_in">export</span> CC=<span class="variable">$&#123;DEVROOT&#125;</span>/usr/bin/cc</div><div class="line">  <span class="built_in">export</span> LD=<span class="variable">$&#123;DEVROOT&#125;</span>/usr/bin/ld</div><div class="line">  <span class="built_in">export</span> CPP=<span class="variable">$&#123;DEVROOT&#125;</span>/usr/bin/cpp</div><div class="line">  <span class="built_in">export</span> CXX=<span class="variable">$&#123;DEVROOT&#125;</span>/usr/bin/g++</div><div class="line">  <span class="built_in">export</span> AR=<span class="variable">$&#123;DEVROOT&#125;</span>/usr/bin/ar</div><div class="line">  <span class="built_in">export</span> AS=<span class="variable">$&#123;DEVROOT&#125;</span>/usr/bin/as</div><div class="line">  <span class="built_in">export</span> NM=<span class="variable">$&#123;DEVROOT&#125;</span>/usr/bin/nm</div><div class="line">  <span class="built_in">export</span> CXXCPP=<span class="variable">$&#123;DEVROOT&#125;</span>/usr/bin/cpp</div><div class="line">  <span class="built_in">export</span> RANLIB=<span class="variable">$&#123;DEVROOT&#125;</span>/usr/bin/ranlib</div><div class="line"></div><div class="line">  rm -rf libwebp-0.5.1	<span class="comment">#根据自己的libwebp版本</span></div><div class="line">  tar xzf libwebp-0.5.1.tar</div><div class="line">  <span class="built_in">cd</span> libwebp-0.5.1</div><div class="line"></div><div class="line">  sh autogen.sh</div><div class="line"></div><div class="line">  ROOTDIR=<span class="string">"/tmp/install.$$.<span class="variable">$&#123;ARCH&#125;</span>"</span></div><div class="line">  rm -rf <span class="string">"<span class="variable">$&#123;ROOTDIR&#125;</span>"</span></div><div class="line">  mkdir -p <span class="string">"<span class="variable">$&#123;ROOTDIR&#125;</span>"</span></div><div class="line"></div><div class="line">  <span class="built_in">export</span> LDFLAGS=<span class="string">"-arch <span class="variable">$&#123;ARCH&#125;</span> -miphoneos-version-min=7.0 -pipe -isysroot <span class="variable">$&#123;SDKPATH&#125;</span> -O3 -DNDEBUG"</span></div><div class="line">  <span class="built_in">export</span> CFLAGS=<span class="string">"-arch <span class="variable">$&#123;ARCH&#125;</span> -miphoneos-version-min=7.0 -pipe -isysroot <span class="variable">$&#123;SDKPATH&#125;</span> -O3 -DNDEBUG"</span></div><div class="line">  <span class="built_in">export</span> CXXFLAGS=<span class="string">"-arch <span class="variable">$&#123;ARCH&#125;</span> -miphoneos-version-min=7.0 -pipe -isysroot <span class="variable">$&#123;SDKPATH&#125;</span> -O3 -DNDEBUG"</span></div><div class="line"></div><div class="line">./configure --host=<span class="variable">$&#123;HOST&#125;</span> --prefix=<span class="variable">$&#123;ROOTDIR&#125;</span> --disable-shared --enable-static \</div><div class="line">            --enable-libwebpdecoder --enable-swap-16bit-csp --build=$(./config.guess)</div><div class="line">  make</div><div class="line">  make install</div><div class="line"></div><div class="line">  LIBLIST=<span class="string">"<span class="variable">$&#123;LIBLIST&#125;</span> <span class="variable">$&#123;ROOTDIR&#125;</span>/lib/libwebp.a"</span></div><div class="line">  cp -Rp <span class="variable">$&#123;ROOTDIR&#125;</span>/include/webp/* <span class="variable">$FINALDIR</span>/Headers/</div><div class="line"></div><div class="line">  <span class="built_in">cd</span> ..</div><div class="line"><span class="keyword">done</span></div><div class="line"></div><div class="line"><span class="variable">$&#123;DEVROOT&#125;</span>/usr/bin/lipo -create <span class="variable">$LIBLIST</span> -output <span class="variable">$FINALDIR</span>/WebP</div><div class="line"></div><div class="line">rm -rf libwebp-0.5.1</div><div class="line">rm -rf <span class="variable">$&#123;BUILDDIR&#125;</span></div></pre></td></tr></table></figure>
<p> 上面的代码需要注意的几个地方，就是<code>SDKPath</code>、<code>SDK</code>变量需改成自己Xcode的SDK的版本号，因为我这个实例用的是<code>libwebp-0.5.1</code>版本，如果用的是其他的版本，则需要把脚本中的所有<code>libwebp-0.5.1</code>替换成你自己的版本名。一切妥当后，执行<code>./build.sh</code>命令，最后会生成一个<code>WebP.framework</code>框架，将其添加到自己的项目中，然后在<code>Build Settings</code>的<code>Framework Search Paths</code>中添加<code>WebP.framework</code>框架所在的目录路径即可。</p>
<h2 id="直接使用官方编译好的framework"><a href="#直接使用官方编译好的framework" class="headerlink" title="直接使用官方编译好的framework"></a>直接使用官方编译好的<code>framework</code></h2><p> 直接使用官方编译好的<code>framework</code>，下载地址请戳<a href="https://developers.google.com/speed/webp/download" target="_blank" rel="external">这里</a>，下载如下如图所示的文件，下载完之后直接改名为<code>WebP.framework</code>，添加到项目中，同样，在<code>Build Settings</code>的<code>Framework Search Paths</code>中添加<code>WebP.framework</code>框架所在的目录路径即可。<br> <img src="http://oc54pu02q.bkt.clouddn.com/QQ20160826-2@2x.png" width="500" height="" alt="" align="center"></p>
<p> <em>项目示例请戳<a href="https://github.com/zhongwuzw/WebP-iOS-example" target="_blank" rel="external">这里</a>，欢迎Star。</em></p>
<h2 id="SDWebImage"><a href="#SDWebImage" class="headerlink" title="SDWebImage"></a>SDWebImage</h2><p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a>支持<code>WebP</code>格式，但是默认不开启，需要添加SubSpecs，具体步骤参看<code>SDWebImage</code>官方说明。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Swift之通过减少动态派发来提升性能]]></title>
      <url>https://zhongwuzw.github.io/2016/08/24/Swift%E4%B9%8B%E9%80%9A%E8%BF%87%E5%87%8F%E5%B0%91%E5%8A%A8%E6%80%81%E6%B4%BE%E5%8F%91%E6%9D%A5%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>Swift是OO（面向对象）的语言，所以少不了方法和属性的重载等特性，程序只能在运行时来确定具体的方法或属性来间接调用或间接访问，这就叫做动态派发。从性能上考虑，对于动态派发的方法，会有常量时间的运行时开销。接下来将介绍三种方法来移除这样的动态性，<code>final</code>，<code>private</code>，全模块优化（Whole Module Optimization），以此提升性能。</p>
<p>考虑下面的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParticleModel</span> </span>&#123;</div><div class="line">	<span class="keyword">var</span> point = ( <span class="number">0.0</span>, <span class="number">0.0</span> )</div><div class="line">	<span class="keyword">var</span> velocity = <span class="number">100.0</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">func</span> <span class="title">updatePoint</span><span class="params">(newPoint: <span class="params">(Double, Double)</span></span></span>, newVelocity: <span class="type">Double</span>) &#123;</div><div class="line">		point = newPoint</div><div class="line">		velocity = newVelocity</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">(newP: <span class="params">(Double, Double)</span></span></span>, newV: <span class="type">Double</span>) &#123;</div><div class="line">		updatePoint(newP, newVelocity: newV)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="type">ParticleModel</span>()</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0.0</span>, through: <span class="number">360</span>, by: <span class="number">1.0</span>) &#123;</div><div class="line">	p.update((i * sin(i), i), newV:i*<span class="number">1000</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上述代码所示，调用过程为：</p>
<ol>
<li>调用变量<code>p</code>的<code>update</code>方法。</li>
<li>调用<code>p</code>的<code>updatePoint</code>方法。</li>
<li>获取<code>p</code>的元组类型变量<code>point</code>。</li>
<li>获取<code>p</code>的属性velocity。</li>
</ol>
<p>由于<code>ParticleModel</code>可以被子类，所以其方法和属性就能被重载，这就不可避免的需要使用动态调用。</p>
<p>在Swift中，动态调用是通过在一个方法表中找到方法然后执行间接的调用（类似于C++的虚函数表），对于这种先查找再调用的过程，其效率是要低于方法的直接调用，而且间接调用会阻止许多编译器优化，这将加重间接调用的开销。接下来将列举一些技巧来禁用动态派发的行为，以达到提升性能的目的。</p>
<a id="more"></a>
<h2 id="当属性、方法、或类不需要被重载时，可在其声明的地方加上final关键字"><a href="#当属性、方法、或类不需要被重载时，可在其声明的地方加上final关键字" class="headerlink" title="当属性、方法、或类不需要被重载时，可在其声明的地方加上final关键字"></a>当属性、方法、或类不需要被重载时，可在其声明的地方加上<code>final</code>关键字</h2><p>在属性，方法或类声明时加上<code>final</code>关键字，表示其不能被重载，这将允许编译器安全的移除动态派发。如下代码所示，<code>point</code>和<code>velocity</code>将直接从对象的存储属性中加载，<code>updatePoint()</code>方法将被直接调用；另外，<code>update()</code>依然会通过动态派发的方式来调用，这样，<code>ParticleModel</code>的子类就可以重载<code>update()</code>来自定义实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParticleModel</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">var</span> point = ( x: <span class="number">0.0</span>, y: <span class="number">0.0</span> )</div><div class="line">	<span class="keyword">final</span> <span class="keyword">var</span> velocity = <span class="number">100.0</span></div><div class="line"></div><div class="line">	<span class="keyword">final</span> <span class="function"><span class="keyword">func</span> <span class="title">updatePoint</span><span class="params">(newPoint: <span class="params">(Double, Double)</span></span></span>, newVelocity: <span class="type">Double</span>) &#123;</div><div class="line">		point = newPoint</div><div class="line">		velocity = newVelocity</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">(newP: <span class="params">(Double, Double)</span></span></span>, newV: <span class="type">Double</span>) &#123;</div><div class="line">		updatePoint(newP, newVelocity: newV)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了上面所示，在属性和方法声明前加<code>final</code>关键字，还可以直接在类上加<code>final</code>，表示该类将不能作为父类被子类化，隐含的表明该类的所有的方法和属性都是<code>final</code>的。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ParticleModel</span> </span>&#123;</div><div class="line">	<span class="keyword">var</span> point = ( x: <span class="number">0.0</span>, y: <span class="number">0.0</span> )</div><div class="line">	<span class="keyword">var</span> velocity = <span class="number">100.0</span></div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="在属性、方法、或类声明前加private关键字，将限制其只能在同一个文件中被引用"><a href="#在属性、方法、或类声明前加private关键字，将限制其只能在同一个文件中被引用" class="headerlink" title="在属性、方法、或类声明前加private关键字，将限制其只能在同一个文件中被引用"></a>在属性、方法、或类声明前加<code>private</code>关键字，将限制其只能在同一个文件中被引用</h2><p>在声明前加<code>private</code>关键字，将限制其只能在当前文件中被引用，这将允许编译器在当前文件中找到所有潜在的重载声明，编译器会对这些<code>private</code>关键字的方法或属性进行优化，移除间接的方法调用以及属性访问。</p>
<p>假设在当前文件中没有类重载<code>ParticleModel</code>，那么编译器将移除所有带有<code>private</code>声明的动态派发调用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParticleModel</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">var</span> point = ( x: <span class="number">0.0</span>, y: <span class="number">0.0</span> )</div><div class="line">	<span class="keyword">private</span> <span class="keyword">var</span> velocity = <span class="number">100.0</span></div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">updatePoint</span><span class="params">(newPoint: <span class="params">(Double, Double)</span></span></span>, newVelocity: <span class="type">Double</span>) &#123;</div><div class="line">		point = newPoint</div><div class="line">		velocity = newVelocity</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">(newP: <span class="params">(Double, Double)</span></span></span>, newV: <span class="type">Double</span>) &#123;</div><div class="line">		updatePoint(newP, newVelocity: newV)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上代码所示，<code>point</code>和<code>velocity</code>将直接访问，<code>updatePoint()</code>方法也将直接被调用，而<code>update()</code>方法由于没有加<code>private</code>关键字，依然是只能间接调用。<br>同样，<code>private</code>可以加在类的声明前，等同于类的所有方法和属性都将加上<code>private</code>关键字。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ParticleModel</span> </span>&#123;</div><div class="line">	<span class="keyword">var</span> point = ( x: <span class="number">0.0</span>, y: <span class="number">0.0</span> )</div><div class="line">	<span class="keyword">var</span> velocity = <span class="number">100.0</span></div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="在使用internal的声明中通过使用Whole-Module-Optimization来隐式的推断出final"><a href="#在使用internal的声明中通过使用Whole-Module-Optimization来隐式的推断出final" class="headerlink" title="在使用internal的声明中通过使用Whole Module Optimization来隐式的推断出final"></a>在使用<code>internal</code>的声明中通过使用<code>Whole Module Optimization</code>来隐式的推断出<code>final</code></h2><p>默认的情况下，Xcode将单独编译源文件，这会限制编译器优化的程度，Xcode 7后，增加了<code>Whole Module Optimization</code>选项，它能允许编译器在同一个模块（Module）中分析所有的源文件来进行优化，可以在Xcode的<code>Building Settings</code>中开启该选项，如下图所示。<br> <img src="http://oc54pu02q.bkt.clouddn.com/QQ20160825-0@2x.png" width="500" height="" alt="" align="center"></p>
<p> 在开启<code>Whole Module Optimization</code>选项，且声明为<code>internal</code>(默认级别)的情况下，模块的所有文件将同时被编译，这将允许编译器对整个模块一起分析，并对<strong>没有被重载</strong>且声明为<code>internal</code>级别的类、方法或属性添加<code>final</code>关键字。<br> 如下代码所示，我们修改一下<code>ParticleModel</code>类，添加<code>public</code>关键字：</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParticleModel</span> </span>&#123;</div><div class="line">	<span class="keyword">var</span> point = ( x: <span class="number">0.0</span>, y: <span class="number">0.0</span> )</div><div class="line">	<span class="keyword">var</span> velocity = <span class="number">100.0</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">func</span> <span class="title">updatePoint</span><span class="params">(newPoint: <span class="params">(Double, Double)</span></span></span>, newVelocity: <span class="type">Double</span>) &#123;</div><div class="line">		point = newPoint</div><div class="line">		velocity = newVelocity</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">(newP: <span class="params">(Double, Double)</span></span></span>, newV: <span class="type">Double</span>) &#123;</div><div class="line">		updatePoint(newP, newVelocity: newV)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="type">ParticleModel</span>()</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0.0</span>, through: times, by: <span class="number">1.0</span>) &#123;</div><div class="line">	p.update((i * sin(i), i), newV:i*<span class="number">1000</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 如上代码，当开启<code>Whole Module Optimization</code>选项的情况下，编译器能在属性<code>point</code>,<code>velotity</code>，以及<code>updatePoint()</code>方法上推断出<code>final</code>，既相当于在<code>point</code>、<code>velocity</code>、<code>updatePoint()</code>声明前加上<code>final</code>关键字，而<code>update()</code>方法由于是<code>public</code>级别，所以无法推断出<code>final</code>关键字，其仍将是间接调用。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li>当使用<code>private</code>或<code>final</code>关键字，或者在开启<code>Whole Module Optimization</code>选项，声明为<code>internal</code>级别的<strong>没有被重载</strong>的方法下，将直接调用，在编译时确定。</li>
<li>运行时决定的动态派发的情形包括：<ul>
<li>继承自<code>NSObject</code>或者方法有@objc前缀。</li>
<li>使用Swift的方法表的方式，除去上述情况下，将采用这种方式。</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Swift中使用Objective-C的Runtime]]></title>
      <url>https://zhongwuzw.github.io/2016/08/23/Swift%E4%B8%AD%E4%BD%BF%E7%94%A8Objective-C%E7%9A%84Runtime/</url>
      <content type="html"><![CDATA[<h1 id="Swift调用Objective-C的Runtime"><a href="#Swift调用Objective-C的Runtime" class="headerlink" title="Swift调用Objective-C的Runtime"></a>Swift调用Objective-C的Runtime</h1><hr>
<p>首先，我们来测试一下使用Swift代码来调用Objective-C Runtime的方法，首先创建两个类，用来做对比，一个是纯的Swift类，另一个继承自NSObject：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//纯Swift类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwiftClass</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> aBool = <span class="literal">true</span></div><div class="line">    <span class="keyword">var</span> aInt = <span class="number">3</span></div><div class="line">    <span class="keyword">var</span> aStrig = <span class="string">"sss"</span></div><div class="line">    <span class="keyword">var</span> aObject :<span class="type">AnyObject</span>?</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">swiftTest</span><span class="params">()</span></span> &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//继承自NSObject的类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwiftWithOCClass</span> :<span class="title">NSObject</span></span>&#123;</div><div class="line">    <span class="keyword">var</span> aBool = <span class="literal">true</span></div><div class="line">    <span class="keyword">var</span> aInt = <span class="number">3</span></div><div class="line">    <span class="keyword">var</span> aStrig = <span class="string">"sss"</span></div><div class="line">    <span class="keyword">var</span> aObject :<span class="type">AnyObject</span>?</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">swiftTest</span><span class="params">(aCharacter:Character)</span></span> &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">justTest</span><span class="params">()</span></span> &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>接下来，我们来创建一个方法，用来获取Class的方法和属性，代码如下：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">func getMethodListAndProperties(cls:AnyClass) -&gt; <span class="built_in">Void</span> &#123;</div><div class="line">    var methodCount:<span class="built_in">UInt32</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">let</span> methodList = class_copyMethodList(cls, &amp;methodCount)</div><div class="line">    </div><div class="line">    //打印方法</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;<span class="built_in">Int</span>(methodCount) &#123;</div><div class="line">        <span class="keyword">let</span> method = methodList[i]</div><div class="line">        print(<span class="built_in">String</span>(<span class="built_in">UTF8String</span>:method_getTypeEncoding(method)))</div><div class="line">        print(<span class="built_in">String</span>(_sel:method_getName(method)))</div><div class="line">    &#125;</div><div class="line">    free(methodList)</div><div class="line">    </div><div class="line">    var propertiesCount:<span class="built_in">UInt32</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">let</span> propertiesList = class_copyPropertyList(cls, &amp;propertiesCount)</div><div class="line">    </div><div class="line">    //打印属性</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;<span class="built_in">Int</span>(propertiesCount) &#123;</div><div class="line">        <span class="keyword">let</span> property = propertiesList[i]</div><div class="line">        print(<span class="built_in">String</span>(<span class="built_in">UTF8String</span>:property_getName(property)))</div><div class="line">        print(<span class="built_in">String</span>(<span class="built_in">UTF8String</span>:property_getAttributes(property)))</div><div class="line">    &#125;</div><div class="line">    free(propertiesList)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当调用<code>getMethodListAndProperties(SwiftWithOCClass)</code>方法时，其打印结果如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//打印的方法</span></div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"B16@0:8"</span>)</span></span></div><div class="line">aBool</div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"v20@0:8B16"</span>)</span></span></div><div class="line">setABool:</div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"q16@0:8"</span>)</span></span></div><div class="line">aInt</div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"v24@0:8q16"</span>)</span></span></div><div class="line">setAInt:</div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"@16@0:8"</span>)</span></span></div><div class="line">aStrig</div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"v24@0:8@16"</span>)</span></span></div><div class="line">setAStrig:</div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"@16@0:8"</span>)</span></span></div><div class="line">aObject</div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"v24@0:8@16"</span>)</span></span></div><div class="line">setAObject:</div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"v16@0:8"</span>)</span></span></div><div class="line">justTest</div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"@?"</span>)</span></span></div><div class="line"><span class="selector-class">.cxx_destruct</span></div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"@16@0:8"</span>)</span></span></div><div class="line">init</div><div class="line"></div><div class="line"><span class="comment">//打印的属性</span></div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"aBool"</span>)</span></span></div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"TB,N,VaBool"</span>)</span></span></div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"aInt"</span>)</span></span></div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"Tq,N,VaInt"</span>)</span></span></div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"aStrig"</span>)</span></span></div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"T@\"NSString\",N,C,VaStrig"</span>)</span></span></div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"aObject"</span>)</span></span></div><div class="line"><span class="function"><span class="title">Optional</span><span class="params">(<span class="string">"T@,N,&amp;,VaObject"</span>)</span></span></div></pre></td></tr></table></figure>
<ul>
<li><p>当调用<code>getMethodListAndProperties(SwiftClass)</code>方法时，我们发现并没有打印结果，既没有获取到纯Swift类的属性和方法；而继承自<code>NSObject</code>的类SwiftWithOCClass则能够获取到属性和方法，翻阅官方文档（如下图），我们就能找到原因，通过继承<code>NSObject</code>，对象可以拥有运行时且可以被看成Objective-C对象。<br><img src="http://oc54pu02q.bkt.clouddn.com/QQ20160824-0@2x.png" width="500" height="" alt="" align="center"></p>
</li>
<li><p>我们不禁要问，对于纯Swift类，难道就没有办法使用Objective-C运行时了么？答案是否定的，我们可以使用<code>dynamic</code>修饰符，实验一下，在纯Swift类的属性aBool中加入<code>dynamic</code>修饰符，代码如下,我们发现，可以通过运行时找到aBool属性的两个访问器方法以及属性名。</p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwiftClass</span> </span>&#123;</div><div class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> aBool = <span class="literal">true</span></div><div class="line">    <span class="keyword">var</span> aInt = <span class="number">3</span></div><div class="line">    <span class="keyword">var</span> aStrig = <span class="string">"sss"</span></div><div class="line">    <span class="keyword">var</span> aObject :<span class="type">AnyObject</span>?</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">swiftTest</span><span class="params">()</span></span> &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//打印结果</span></div><div class="line"><span class="type">Optional</span>(<span class="string">"B16@0:8"</span>)</div><div class="line">aBool</div><div class="line"><span class="type">Optional</span>(<span class="string">"v20@0:8B16"</span>)</div><div class="line">setABool:</div><div class="line"><span class="type">Optional</span>(<span class="string">"aBool"</span>)</div><div class="line"><span class="type">Optional</span>(<span class="string">"TB,N,VaBool"</span>)</div></pre></td></tr></table></figure>
<ul>
<li>而当调用<code>getMethodListAndProperties(SwiftWithOCClass)</code>时，大多数方法都打印出来了，但有一个方法没获取到，为<code>func swiftTest(aCharacter:Character)</code>，原因是该方法的参数是Character类型，它是Swift特有的，无法转化(Bridge)为OC的类型，所以无法通过运行时获取到该方法。</li>
</ul>
<h1 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h1><hr>
<p>在使用Objective-C的Runtime时，经常会用到Method Swizzling技术，该技术通常在<code>load</code>方法中实现。而在Swift中不允许定义<code>load</code>方法，否则编译器会报错，所以，如果要实现Method Swizzling，有几种解决方案：</p>
<ul>
<li>在<code>initialize</code>中来实现，但是需要注意的是<code>initialize</code>可能会被调用多次，所以需要在<code>initialize</code>实现中做一些判断，比如判断是否是当前类，而不是子类，使用<code>dispatch_once</code>来进行操作。 </li>
<li>在App Delegate中实现Method Swizzling：在AppDelegate的<code>application(_:didFinishLaunchingWithOptions:)</code>方法中进行Method Swizzling。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Swift的Designated和Convenience初始化器]]></title>
      <url>https://zhongwuzw.github.io/2016/08/19/Swift%E7%9A%84Designated%E5%92%8CConvenience%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Swift中，为了确保类的存储属性都能有一个初始值，提供了几种初始化的方法，接下来将讨论一下Desinated(指定)、Convenience（便捷）初始化器。</p>
<h1 id="Designated（指定）初始化器"><a href="#Designated（指定）初始化器" class="headerlink" title="Designated（指定）初始化器"></a>Designated（指定）初始化器</h1><ul>
<li><p>之前使用过Objective-C的应该比较了解指定初始化器，很多类都提供了指定初始化器，如UIViewController的为：<code>- (instancetype)initWithNibName:(NSString *)nibName bundle:(NSBundle *)nibBundle</code>,UIView的<code>- (instancetype)initWithFrame:(CGRect)aRect</code>，其作用是该类或者其子类在初始化的过程中都会调用指定初始化器。</p>
</li>
<li><p>当在类中定义指定初始化器时，该初始化器会初始化该类的所有存储属性，且当该类是有父类时，<strong>必须</strong>调用父类的<strong>指定</strong>初始化器，注意顺序，先初始化该类自己定义的存储属性，再使用super来调用父类的指定初始化器，跌倒过来编译器会报错。</p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecipeIngredient</span>: <span class="title">Food</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> quantity: <span class="type">Int</span></div><div class="line">    <span class="comment">//指定初始化器</span></div><div class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, quantity: <span class="type">Int</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.quantity = quantity</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name) <span class="comment">//放在该类存储属性初始化之后</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">override</span> <span class="keyword">convenience</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, quantity: <span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>每一个类都必须至少有一个指定初始化器。</li>
</ul>
<a id="more"></a>
<h1 id="Convenience（便捷）初始化器"><a href="#Convenience（便捷）初始化器" class="headerlink" title="Convenience（便捷）初始化器"></a>Convenience（便捷）初始化器</h1><ul>
<li>便捷初始化器需要带一个convenience修饰符，如下代码,在便捷初始化器的定义中，<strong>必须先调用其他的初始化器之后，再赋类的存储属性值</strong>。</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">convenience</span> <span class="selector-tag">init</span>(parameters) &#123;</div><div class="line">    statements</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>便捷初始化器如果重载了父类的指定初始化器，则必须使用override修饰符。</p>
</li>
<li><p>如果子类提供了其父类的<strong>所有</strong>（注意：必须是所有的）指定初始化器的实现，实现有两种，一种是子类的存储属性都提供了默认值，且没有定义指定初始化器，则会自动集成父类的指定初始化器；另一种是在子类中重新定义，子类中重新定义的方法可以是便捷初始化器，既子类中的便捷初始化器可以重载父类的指定初始化器。这样子类就会自动继承父类的便捷初始化器。</p>
</li>
</ul>
<h1 id="指定初始化器和便捷初始化器之间的关系"><a href="#指定初始化器和便捷初始化器之间的关系" class="headerlink" title="指定初始化器和便捷初始化器之间的关系"></a>指定初始化器和便捷初始化器之间的关系</h1><p>指定初始化器和便捷初始化器之间的3个法则：</p>
<ol>
<li>指定初始化器必须调用其<strong><em>直接</em></strong>父类的指定初始化器。</li>
<li>便捷初始化器必须调用该类中其他的初始化器，其初始化器的类型不限。</li>
<li>在便捷初始化器的调用链中最后必须调用一个指定初始化器。</li>
</ol>
<p>最后，直接上官方文档的图示就会对上面的3个规则有比较清晰的认识：<br> <img src="http://oc54pu02q.bkt.clouddn.com/QQ20160819-0@2x.png" width="500" height="254" alt="" align="center"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[知乎日报iOS]]></title>
      <url>https://zhongwuzw.github.io/2016/08/18/%E7%9F%A5%E4%B9%8E%E6%97%A5%E6%8A%A5iOS/</url>
      <content type="html"><![CDATA[<p><strong>Disclaimer - 声明</strong><br><em>Zhihu</em> is a trademark of <em>Zhihu. Inc</em>. This app is not created nor endorsed by Zhihu Inc. All the information and content accessible through Zhihu Daily Purify are subject to Zhihu’s copyright and terms of use. This is a free app and does not charge for anything. All content are available for free from <a href="http://www.zhihu.com" target="_blank" rel="external">Zhihu</a>.</p>
<p>『知乎』是 <em>知乎. Inc</em> 的注册商标。本软件与其代码非由知乎创作或维护。软件中所包含的信息与内容皆违反版权与知乎用户协议。它是一个免费软件，使用它不收取您任何费用。其中的所有内容均可在<a href="http://www.zhihu.com" target="_blank" rel="external">知乎</a>获取。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近工作工作不是很忙，所以准备开发项目练练手，之前发现了这个<em><a href="https://github.com/izzyleung/ZhihuDailyPurify/" target="_blank" rel="external">知乎日报API</a></em>,其提供了知乎日报的API地址，所以决定开发知乎日报。先上<em><a href="https://github.com/zhongwuzw/ZhihuDaily" target="_blank" rel="external">Github地址</a></em>，欢迎<em>Star、Issues、Pull Request</em>。</p>
<h1 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h1><h2 id="1-应用主页部分："><a href="#1-应用主页部分：" class="headerlink" title="1.应用主页部分："></a>1.应用主页部分：</h2><p><img src="https://raw.githubusercontent.com/zhongwuzw/ZhihuDaily/master/images/demo1.gif" alt=""><br><a id="more"></a></p>
<ul>
<li>主页中最上方的滚动条实现思路：该无限滚动条有很多实现方式，包括使用UIScrollView，添加3个子视图用于管理，每次滑动后都进行3个子视图内容的重新赋值。之前，我采用过这种思路，所以又想了另外一种方法，直接使用UICollectionView来实现，在第一个和最后一个数据源中添加最后一个、第一个数据，在scrollViewDidScroll中处理到达左右两边后的跳转即可，代码如下：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</div><div class="line">	[<span class="keyword">self</span> scrollCollectionViewToCorrectIndexPath];</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)scrollCollectionViewToCorrectIndexPath&#123;</div><div class="line">	<span class="keyword">float</span> contentOffsetWhenFullyScrolledRight = <span class="keyword">self</span>.frame.size.width * ([<span class="keyword">self</span>.dataArray count] <span class="number">-1</span>);</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">self</span>.collectionView.contentOffset.x == contentOffsetWhenFullyScrolledRight) 	&#123;</div><div class="line">        <span class="built_in">NSIndexPath</span> *newIndexPath = [<span class="built_in">NSIndexPath</span> indexPathForItem:<span class="number">1</span> inSection:<span class="number">0</span>];</div><div class="line">        </div><div class="line">        [<span class="keyword">self</span>.collectionView scrollToItemAtIndexPath:newIndexPath atScrollPosition:<span class="built_in">UICollectionViewScrollPositionLeft</span> animated:<span class="literal">NO</span>];</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.collectionView.contentOffset.x == <span class="number">0</span>)  &#123;</div><div class="line">        <span class="built_in">NSIndexPath</span> *newIndexPath = [<span class="built_in">NSIndexPath</span> indexPathForItem:([<span class="keyword">self</span>.dataArray count] <span class="number">-2</span>) inSection:<span class="number">0</span>];</div><div class="line">        </div><div class="line">        [<span class="keyword">self</span>.collectionView scrollToItemAtIndexPath:newIndexPath atScrollPosition:<span class="built_in">UICollectionViewScrollPositionLeft</span> animated:<span class="literal">NO</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>由于主页上方的无限滚动条是有UICollectionView来实现的，所以为了实现主页新闻页滑动时的动态放缩，直接在setFrame中invalidate collectionView的layout即可(一开始使用AutoLayout来调整，后来发现当快速滑动时会出现短时间错位的问题，所以只得使用setFrame)：</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">-</span>(void)<span class="selector-tag">setFrame</span><span class="selector-pseudo">:(CGRect)frame</span>&#123;</div><div class="line">    <span class="selector-tag">if</span> (self.height != frame.size.height) &#123;</div><div class="line">        <span class="selector-attr">[self.collectionView.collectionViewLayout invalidateLayout]</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="selector-attr">[super setFrame:frame]</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>项目中多个页面实现了点击状态栏页面滑动到顶部的功能，实现方法无非就是先获取到点击状态栏时的事件，由于AppDelegate继承自UIResponder，所以能够响应事件，作为响应者链最顶层（响应者链如下图所示）的响应者，当前面的Responder无法处理事件而向上传递时，最后会到达AppDelegate，所以统一在AppDelegate中处理状态栏的点击，直接重写<code>- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</code>方法，代码示例如下：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    [<span class="keyword">super</span> touchesBegan:touches withEvent:event];</div><div class="line">    </div><div class="line">    <span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *events = [event allTouches];</div><div class="line">    <span class="built_in">UITouch</span> *touch = [events anyObject];</div><div class="line">    <span class="built_in">CGPoint</span> location = [touch locationInView:<span class="keyword">self</span>.window];</div><div class="line">    <span class="built_in">CGRect</span> statusBarFrame = [<span class="built_in">UIApplication</span> sharedApplication].statusBarFrame;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="built_in">CGRectContainsPoint</span>(statusBarFrame, location)) &#123;</div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:STATUS_BAR_TAP_NOTIFICATION object:<span class="literal">nil</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://oc54pu02q.bkt.clouddn.com/responder_chain.png" alt="image"></p>
<ul>
<li>在使用Notification时需要注意的就是Observer对象一定要在自己被销毁之前remove掉Observer。还有一个注意的点就是Observer在接收到Notification执行时的线程与发出Notification的线程是一致的，所以如果存在子线程发Notification的情况，在Observer处理时不要直接操作UI。</li>
</ul>
<h2 id="2-新闻详细页部分："><a href="#2-新闻详细页部分：" class="headerlink" title="2.新闻详细页部分："></a>2.新闻详细页部分：</h2><p><img src="https://raw.githubusercontent.com/zhongwuzw/ZhihuDaily/master/images/demo2.gif" alt=""><br><img src="https://raw.githubusercontent.com/zhongwuzw/ZhihuDaily/master/images/demo3.gif" alt=""></p>
<ul>
<li>新闻主页和详细页部分使用了一个单例Manager来进行数据的管理，使用外观模式，Manager提供简洁的接口，如下代码：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HomePageDataManager</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span>&lt;NewsListResponseModel *&gt; *homePageArray;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;TopNewsResponseModel *&gt; *topNewsArray;</div><div class="line"></div><div class="line">SYNTHESIZE_SINGLETON_FOR_CLASS_HEADER(HomePageDataManager)</div><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)getLatestNewsWithSuccess:(HttpClientSuccessBlock)success</div><div class="line">                                              fail:(HttpClientFailureBlock)fail;</div><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)getPreviousNewsWithSuccess:(HttpClientSuccessBlock)success</div><div class="line">                                              fail:(HttpClientFailureBlock)fail;</div><div class="line">- (<span class="built_in">NSInteger</span>)numberofSections;</div><div class="line">- (<span class="built_in">NSInteger</span>)numberofRowsInSection:(<span class="built_in">NSInteger</span>)section;</div><div class="line">- (NewsResponseModel *)modelForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</div><div class="line">- (<span class="built_in">NSString</span> *)headerTitleForSection:(<span class="built_in">NSInteger</span>)section;</div><div class="line">- (<span class="built_in">NSInteger</span>)getPreviousNewsWithSection:(<span class="built_in">NSInteger</span> *)section currentID:(<span class="built_in">NSInteger</span>)currentID;</div><div class="line">- (<span class="built_in">NSInteger</span>)getNextNewsWithSection:(<span class="built_in">NSInteger</span> *)section currentID:(<span class="built_in">NSInteger</span>)currentID;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<ul>
<li>因为在详细页可以进行新闻的上下切换，所以有可能更新数据源，这样，当返回到主页时，数据源可能已经更新，这个时候主页需要重新reload 数据，否则会导致崩溃。</li>
<li><p>详细页的上下切换动画实现，直接使用UIView提供的animateWithDuration方法，上下切换时只是View的切换，由同一个控制器管理。</p>
<h2 id="3-主题日报部分："><a href="#3-主题日报部分：" class="headerlink" title="3.主题日报部分："></a>3.主题日报部分：</h2><p><img src="https://raw.githubusercontent.com/zhongwuzw/ZhihuDaily/master/images/demo4.gif" alt=""></p>
</li>
<li><p>主题日报部分基本和主页类似，在主题日报列表中进行切换时，不再重新创建Controller以及UI，而是直接reload数据。</p>
<h2 id="4-夜间部分："><a href="#4-夜间部分：" class="headerlink" title="4.夜间部分："></a>4.夜间部分：</h2><p><img src="https://raw.githubusercontent.com/zhongwuzw/ZhihuDaily/master/images/demo5.gif" alt=""></p>
</li>
<li><p>夜间模式实现：使用UIView的Category，类别中使用Objective-C的关联对象来存储模式的配置项，并且作为Observer来监听夜间模式的切换。</p>
</li>
</ul>
<h2 id="5-设置-移动网络不下载图片"><a href="#5-设置-移动网络不下载图片" class="headerlink" title="5.设置-移动网络不下载图片"></a>5.设置-移动网络不下载图片</h2><p><img src="https://raw.githubusercontent.com/zhongwuzw/ZhihuDaily/master/images/demo6.gif" alt=""></p>
<ul>
<li>实现：使用NSURLProtocol来进行图片的管理，这里需要注意的就是要解决AF、SDWebCache使用NSURLSession的问题。</li>
</ul>
<h2 id="Features-特性"><a href="#Features-特性" class="headerlink" title="Features - 特性"></a>Features - 特性</h2><ul>
<li>实现知乎日报大多数功能</li>
<li>没有广告</li>
</ul>
<h2 id="TODO-后续实现"><a href="#TODO-后续实现" class="headerlink" title="TODO - 后续实现"></a>TODO - 后续实现</h2><ul>
<li><del>网络状况切换管理</del> （已完成）</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>https://zhongwuzw.github.io/2016/08/13/hello-world/</url>
      <content type="html"><![CDATA[<p>Hello World，以前在学习以及项目开发中学到的很多知识点，都会记录在我的印象笔记中，作为整理学习，但是现在，我要开始把我的一些积累放到我的这个小博客上，有问题欢迎大家指正，也附上我的<a href="https://github.com/zhongwuzw" target="_blank" rel="external">Github</a>地址。ps:近期我会整理一下我的印象笔记，将一些知识点放到博客上来。</p>
]]></content>
    </entry>
    
  
  
</search>
